# This file is automatically generated by _generate_pyx.py.
# Do not edit manually!

from libc.math cimport NAN

include "_ufuncs_extra_code_common.pxi"
include "_ufuncs_extra_code.pxi"
__all__ = ['agm', 'airy', 'airye', 'bdtr', 'bdtrc', 'bdtri', 'bdtrik', 'bdtrin', 'bei', 'beip', 'ber', 'berp', 'besselpoly', 'beta', 'betainc', 'betaincc', 'betainccinv', 'betaincinv', 'betaln', 'binom', 'boxcox', 'boxcox1p', 'btdtr', 'btdtri', 'btdtria', 'btdtrib', 'cbrt', 'chdtr', 'chdtrc', 'chdtri', 'chdtriv', 'chndtr', 'chndtridf', 'chndtrinc', 'chndtrix', 'cosdg', 'cosm1', 'cotdg', 'dawsn', 'ellipe', 'ellipeinc', 'ellipj', 'ellipk', 'ellipkinc', 'ellipkm1', 'elliprc', 'elliprd', 'elliprf', 'elliprg', 'elliprj', 'entr', 'erf', 'erfc', 'erfcinv', 'erfcx', 'erfi', 'erfinv', 'eval_chebyc', 'eval_chebys', 'eval_chebyt', 'eval_chebyu', 'eval_gegenbauer', 'eval_genlaguerre', 'eval_hermite', 'eval_hermitenorm', 'eval_jacobi', 'eval_laguerre', 'eval_legendre', 'eval_sh_chebyt', 'eval_sh_chebyu', 'eval_sh_jacobi', 'eval_sh_legendre', 'exp1', 'exp10', 'exp2', 'expi', 'expit', 'expm1', 'expn', 'exprel', 'fdtr', 'fdtrc', 'fdtri', 'fdtridfd', 'fresnel', 'gamma', 'gammainc', 'gammaincc', 'gammainccinv', 'gammaincinv', 'gammaln', 'gammasgn', 'gdtr', 'gdtrc', 'gdtria', 'gdtrib', 'gdtrix', 'hankel1', 'hankel1e', 'hankel2', 'hankel2e', 'huber', 'hyp0f1', 'hyp1f1', 'hyp2f1', 'hyperu', 'i0', 'i0e', 'i1', 'i1e', 'inv_boxcox', 'inv_boxcox1p', 'it2i0k0', 'it2j0y0', 'it2struve0', 'itairy', 'iti0k0', 'itj0y0', 'itmodstruve0', 'itstruve0', 'iv', 'ive', 'j0', 'j1', 'jv', 'jve', 'k0', 'k0e', 'k1', 'k1e', 'kei', 'keip', 'kelvin', 'ker', 'kerp', 'kl_div', 'kn', 'kolmogi', 'kolmogorov', 'kv', 'kve', 'log1p', 'log_expit', 'log_ndtr', 'loggamma', 'logit', 'lpmv', 'mathieu_a', 'mathieu_b', 'mathieu_cem', 'mathieu_modcem1', 'mathieu_modcem2', 'mathieu_modsem1', 'mathieu_modsem2', 'mathieu_sem', 'modfresnelm', 'modfresnelp', 'modstruve', 'nbdtr', 'nbdtrc', 'nbdtri', 'nbdtrik', 'nbdtrin', 'ncfdtr', 'ncfdtri', 'ncfdtridfd', 'ncfdtridfn', 'ncfdtrinc', 'nctdtr', 'nctdtridf', 'nctdtrinc', 'nctdtrit', 'ndtr', 'ndtri', 'ndtri_exp', 'nrdtrimn', 'nrdtrisd', 'obl_ang1', 'obl_ang1_cv', 'obl_cv', 'obl_rad1', 'obl_rad1_cv', 'obl_rad2', 'obl_rad2_cv', 'owens_t', 'pbdv', 'pbvv', 'pbwa', 'pdtr', 'pdtrc', 'pdtri', 'pdtrik', 'poch', 'powm1', 'pro_ang1', 'pro_ang1_cv', 'pro_cv', 'pro_rad1', 'pro_rad1_cv', 'pro_rad2', 'pro_rad2_cv', 'pseudo_huber', 'psi', 'radian', 'rel_entr', 'rgamma', 'round', 'shichi', 'sici', 'sindg', 'smirnov', 'smirnovi', 'spence', 'sph_harm', 'stdtr', 'stdtridf', 'stdtrit', 'struve', 'tandg', 'tklmbda', 'voigt_profile', 'wofz', 'wright_bessel', 'wrightomega', 'xlog1py', 'xlogy', 'y0', 'y1', 'yn', 'yv', 'yve', 'zetac', 'geterr', 'seterr', 'errstate', 'jn']
cdef void loop_D_DDDD__As_DDDD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex, double complex, double complex) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0], <double complex>(<double complex*>ip1)[0], <double complex>(<double complex*>ip2)[0], <double complex>(<double complex*>ip3)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_DDDD__As_FFFF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex, double complex, double complex) noexcept nogil>func)(<double complex>(<float complex*>ip0)[0], <double complex>(<float complex*>ip1)[0], <double complex>(<float complex*>ip2)[0], <double complex>(<float complex*>ip3)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_DDD__As_DDD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex, double complex) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0], <double complex>(<double complex*>ip1)[0], <double complex>(<double complex*>ip2)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_D_DDD__As_FFF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex, double complex) noexcept nogil>func)(<double complex>(<float complex*>ip0)[0], <double complex>(<float complex*>ip1)[0], <double complex>(<float complex*>ip2)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_D_DD__As_DD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0], <double complex>(<double complex*>ip1)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_D_DD__As_FF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex) noexcept nogil>func)(<double complex>(<float complex*>ip0)[0], <double complex>(<float complex*>ip1)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_D_D__As_D_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_D_D__As_F_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex) noexcept nogil>func)(<double complex>(<float complex*>ip0)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_D_Dld__As_Dld_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, long, double) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0], <long>(<long*>ip1)[0], <double>(<double*>ip2)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_D_dD__As_dD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double complex) noexcept nogil>func)(<double>(<double*>ip0)[0], <double complex>(<double complex*>ip1)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_D_dD__As_fF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double complex) noexcept nogil>func)(<double>(<float*>ip0)[0], <double complex>(<float complex*>ip1)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_D_ddD__As_ddD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double complex) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double complex>(<double complex*>ip2)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_D_ddD__As_ffF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double complex) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double complex>(<float complex*>ip2)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_D_dddD__As_dddD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double, double complex) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double complex>(<double complex*>ip3)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_dddD__As_fffF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double, double complex) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double complex>(<float complex*>ip3)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_dddd__As_dddd_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_dddd__As_ffff_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double, double) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double>(<float*>ip3)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_iidd__As_lldd_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        if <int>(<long*>ip0)[0] == (<long*>ip0)[0] and <int>(<long*>ip1)[0] == (<long*>ip1)[0]:
            ov0 = (<double complex(*)(int, int, double, double) noexcept nogil>func)(<int>(<long*>ip0)[0], <int>(<long*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0])
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <double complex>NAN
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_lD__As_lD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(long, double complex) noexcept nogil>func)(<long>(<long*>ip0)[0], <double complex>(<double complex*>ip1)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_d_d__As_d_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double) noexcept nogil>func)(<double>(<double*>ip0)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_d_d__As_f_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double) noexcept nogil>func)(<double>(<float*>ip0)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_d_dd__As_dd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_d_dd__As_ff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddd__As_ddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddd__As_fff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_d_dddd__As_dddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_d_dddd__As_ffff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double>(<float*>ip3)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_d_dddd_d_As_dddd_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef char *op1 = args[5]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double, double *) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0], &ov1)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
        op1 += steps[5]
    sf_error.check_fpe(func_name)

cdef void loop_d_dddd_d_As_ffff_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef char *op1 = args[5]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double, double *) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double>(<float*>ip3)[0], &ov1)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
        op1 += steps[5]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddddddd__As_ddddddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *ip4 = args[4]
    cdef char *ip5 = args[5]
    cdef char *ip6 = args[6]
    cdef char *op0 = args[7]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double, double, double, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0], <double>(<double*>ip4)[0], <double>(<double*>ip5)[0], <double>(<double*>ip6)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        ip4 += steps[4]
        ip5 += steps[5]
        ip6 += steps[6]
        op0 += steps[7]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddddddd__As_fffffff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *ip4 = args[4]
    cdef char *ip5 = args[5]
    cdef char *ip6 = args[6]
    cdef char *op0 = args[7]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double, double, double, double) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double>(<float*>ip3)[0], <double>(<float*>ip4)[0], <double>(<float*>ip5)[0], <double>(<float*>ip6)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        ip4 += steps[4]
        ip5 += steps[5]
        ip6 += steps[6]
        op0 += steps[7]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddi_d_As_ddl_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef char *op1 = args[4]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        if <int>(<long*>ip2)[0] == (<long*>ip2)[0]:
            ov0 = (<double(*)(double, double, int, double *) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <int>(<long*>ip2)[0], &ov1)
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <double>NAN
            ov1 = <double>NAN
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
        op1 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddiiddd__As_ddllddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *ip4 = args[4]
    cdef char *ip5 = args[5]
    cdef char *ip6 = args[6]
    cdef char *op0 = args[7]
    cdef double ov0
    for i in range(n):
        if <int>(<long*>ip2)[0] == (<long*>ip2)[0] and <int>(<long*>ip3)[0] == (<long*>ip3)[0]:
            ov0 = (<double(*)(double, double, int, int, double, double, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <int>(<long*>ip2)[0], <int>(<long*>ip3)[0], <double>(<double*>ip4)[0], <double>(<double*>ip5)[0], <double>(<double*>ip6)[0])
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <double>NAN
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        ip4 += steps[4]
        ip5 += steps[5]
        ip6 += steps[6]
        op0 += steps[7]
    sf_error.check_fpe(func_name)

cdef void loop_d_did__As_dld_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        if <int>(<long*>ip1)[0] == (<long*>ip1)[0]:
            ov0 = (<double(*)(double, int, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <int>(<long*>ip1)[0], <double>(<double*>ip2)[0])
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <double>NAN
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_d_id__As_ld_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double ov0
    for i in range(n):
        if <int>(<long*>ip0)[0] == (<long*>ip0)[0]:
            ov0 = (<double(*)(int, double) noexcept nogil>func)(<int>(<long*>ip0)[0], <double>(<double*>ip1)[0])
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <double>NAN
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_d_iid__As_lld_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        if <int>(<long*>ip0)[0] == (<long*>ip0)[0] and <int>(<long*>ip1)[0] == (<long*>ip1)[0]:
            ov0 = (<double(*)(int, int, double) noexcept nogil>func)(<int>(<long*>ip0)[0], <int>(<long*>ip1)[0], <double>(<double*>ip2)[0])
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <double>NAN
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_d_ld__As_ld_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(long, double) noexcept nogil>func)(<long>(<long*>ip0)[0], <double>(<double*>ip1)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_d_ldd__As_ldd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(long, double, double) noexcept nogil>func)(<long>(<long*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_d_lddd__As_lddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(long, double, double, double) noexcept nogil>func)(<long>(<long*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_f_f__As_f_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef float ov0
    for i in range(n):
        ov0 = (<float(*)(float) noexcept nogil>func)(<float>(<float*>ip0)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_f_ff__As_ff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef float ov0
    for i in range(n):
        ov0 = (<float(*)(float, float) noexcept nogil>func)(<float>(<float*>ip0)[0], <float>(<float*>ip1)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_f_fff__As_fff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef float ov0
    for i in range(n):
        ov0 = (<float(*)(float, float, float) noexcept nogil>func)(<float>(<float*>ip0)[0], <float>(<float*>ip1)[0], <float>(<float*>ip2)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_g_g__As_g_g(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef long double ov0
    for i in range(n):
        ov0 = (<long double(*)(long double) noexcept nogil>func)(<long double>(<long double*>ip0)[0])
        (<long double *>op0)[0] = <long double>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_i_D_DDDD_As_D_DDDD(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef char *op2 = args[3]
    cdef char *op3 = args[4]
    cdef double complex ov0
    cdef double complex ov1
    cdef double complex ov2
    cdef double complex ov3
    for i in range(n):
        (<int(*)(double complex, double complex *, double complex *, double complex *, double complex *) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0], &ov0, &ov1, &ov2, &ov3)
        (<double complex *>op0)[0] = <double complex>ov0
        (<double complex *>op1)[0] = <double complex>ov1
        (<double complex *>op2)[0] = <double complex>ov2
        (<double complex *>op3)[0] = <double complex>ov3
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
        op2 += steps[3]
        op3 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_D_DDDD_As_F_FFFF(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef char *op2 = args[3]
    cdef char *op3 = args[4]
    cdef double complex ov0
    cdef double complex ov1
    cdef double complex ov2
    cdef double complex ov3
    for i in range(n):
        (<int(*)(double complex, double complex *, double complex *, double complex *, double complex *) noexcept nogil>func)(<double complex>(<float complex*>ip0)[0], &ov0, &ov1, &ov2, &ov3)
        (<float complex *>op0)[0] = <float complex>ov0
        (<float complex *>op1)[0] = <float complex>ov1
        (<float complex *>op2)[0] = <float complex>ov2
        (<float complex *>op3)[0] = <float complex>ov3
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
        op2 += steps[3]
        op3 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_D_DD_As_D_DD(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double complex ov0
    cdef double complex ov1
    for i in range(n):
        (<int(*)(double complex, double complex *, double complex *) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0], &ov0, &ov1)
        (<double complex *>op0)[0] = <double complex>ov0
        (<double complex *>op1)[0] = <double complex>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_D_DD_As_F_FF(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double complex ov0
    cdef double complex ov1
    for i in range(n):
        (<int(*)(double complex, double complex *, double complex *) noexcept nogil>func)(<double complex>(<float complex*>ip0)[0], &ov0, &ov1)
        (<float complex *>op0)[0] = <float complex>ov0
        (<float complex *>op1)[0] = <float complex>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_DDDD_As_d_DDDD(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef char *op2 = args[3]
    cdef char *op3 = args[4]
    cdef double complex ov0
    cdef double complex ov1
    cdef double complex ov2
    cdef double complex ov3
    for i in range(n):
        (<int(*)(double, double complex *, double complex *, double complex *, double complex *) noexcept nogil>func)(<double>(<double*>ip0)[0], &ov0, &ov1, &ov2, &ov3)
        (<double complex *>op0)[0] = <double complex>ov0
        (<double complex *>op1)[0] = <double complex>ov1
        (<double complex *>op2)[0] = <double complex>ov2
        (<double complex *>op3)[0] = <double complex>ov3
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
        op2 += steps[3]
        op3 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_DDDD_As_f_FFFF(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef char *op2 = args[3]
    cdef char *op3 = args[4]
    cdef double complex ov0
    cdef double complex ov1
    cdef double complex ov2
    cdef double complex ov3
    for i in range(n):
        (<int(*)(double, double complex *, double complex *, double complex *, double complex *) noexcept nogil>func)(<double>(<float*>ip0)[0], &ov0, &ov1, &ov2, &ov3)
        (<float complex *>op0)[0] = <float complex>ov0
        (<float complex *>op1)[0] = <float complex>ov1
        (<float complex *>op2)[0] = <float complex>ov2
        (<float complex *>op3)[0] = <float complex>ov3
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
        op2 += steps[3]
        op3 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_DD_As_d_DD(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double complex ov0
    cdef double complex ov1
    for i in range(n):
        (<int(*)(double, double complex *, double complex *) noexcept nogil>func)(<double>(<double*>ip0)[0], &ov0, &ov1)
        (<double complex *>op0)[0] = <double complex>ov0
        (<double complex *>op1)[0] = <double complex>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_DD_As_f_FF(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double complex ov0
    cdef double complex ov1
    for i in range(n):
        (<int(*)(double, double complex *, double complex *) noexcept nogil>func)(<double>(<float*>ip0)[0], &ov0, &ov1)
        (<float complex *>op0)[0] = <float complex>ov0
        (<float complex *>op1)[0] = <float complex>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_dd_As_d_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double *, double *) noexcept nogil>func)(<double>(<double*>ip0)[0], &ov0, &ov1)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_dd_As_f_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double *, double *) noexcept nogil>func)(<double>(<float*>ip0)[0], &ov0, &ov1)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_dddd_As_d_dddd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef char *op2 = args[3]
    cdef char *op3 = args[4]
    cdef double ov0
    cdef double ov1
    cdef double ov2
    cdef double ov3
    for i in range(n):
        (<int(*)(double, double *, double *, double *, double *) noexcept nogil>func)(<double>(<double*>ip0)[0], &ov0, &ov1, &ov2, &ov3)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        (<double *>op2)[0] = <double>ov2
        (<double *>op3)[0] = <double>ov3
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
        op2 += steps[3]
        op3 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_dddd_As_f_ffff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef char *op2 = args[3]
    cdef char *op3 = args[4]
    cdef double ov0
    cdef double ov1
    cdef double ov2
    cdef double ov3
    for i in range(n):
        (<int(*)(double, double *, double *, double *, double *) noexcept nogil>func)(<double>(<float*>ip0)[0], &ov0, &ov1, &ov2, &ov3)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        (<float *>op2)[0] = <float>ov2
        (<float *>op3)[0] = <float>ov3
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
        op2 += steps[3]
        op3 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_dd_dd_As_dd_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef char *op1 = args[3]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double, double *, double *) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], &ov0, &ov1)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
        op1 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_i_dd_dd_As_ff_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef char *op1 = args[3]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double, double *, double *) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], &ov0, &ov1)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
        op1 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_i_dd_dddd_As_dd_dddd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef char *op1 = args[3]
    cdef char *op2 = args[4]
    cdef char *op3 = args[5]
    cdef double ov0
    cdef double ov1
    cdef double ov2
    cdef double ov3
    for i in range(n):
        (<int(*)(double, double, double *, double *, double *, double *) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], &ov0, &ov1, &ov2, &ov3)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        (<double *>op2)[0] = <double>ov2
        (<double *>op3)[0] = <double>ov3
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
        op1 += steps[3]
        op2 += steps[4]
        op3 += steps[5]
    sf_error.check_fpe(func_name)

cdef void loop_i_dd_dddd_As_ff_ffff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef char *op1 = args[3]
    cdef char *op2 = args[4]
    cdef char *op3 = args[5]
    cdef double ov0
    cdef double ov1
    cdef double ov2
    cdef double ov3
    for i in range(n):
        (<int(*)(double, double, double *, double *, double *, double *) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], &ov0, &ov1, &ov2, &ov3)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        (<float *>op2)[0] = <float>ov2
        (<float *>op3)[0] = <float>ov3
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
        op1 += steps[3]
        op2 += steps[4]
        op3 += steps[5]
    sf_error.check_fpe(func_name)

cdef void loop_i_ddd_dd_As_ddd_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef char *op1 = args[4]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double, double, double *, double *) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], &ov0, &ov1)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
        op1 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_ddd_dd_As_fff_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef char *op1 = args[4]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double, double, double *, double *) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], &ov0, &ov1)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
        op1 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_ddddd_dd_As_ddddd_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *ip4 = args[4]
    cdef char *op0 = args[5]
    cdef char *op1 = args[6]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double, double, double, double, double *, double *) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0], <double>(<double*>ip4)[0], &ov0, &ov1)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        ip4 += steps[4]
        op0 += steps[5]
        op1 += steps[6]
    sf_error.check_fpe(func_name)

cdef void loop_i_ddddd_dd_As_fffff_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *ip4 = args[4]
    cdef char *op0 = args[5]
    cdef char *op1 = args[6]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double, double, double, double, double *, double *) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double>(<float*>ip3)[0], <double>(<float*>ip4)[0], &ov0, &ov1)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        ip4 += steps[4]
        op0 += steps[5]
        op1 += steps[6]
    sf_error.check_fpe(func_name)

cdef void loop_i_i__As_l_l(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef int ov0
    for i in range(n):
        if <int>(<long*>ip0)[0] == (<long*>ip0)[0]:
            ov0 = (<int(*)(int) noexcept nogil>func)(<int>(<long*>ip0)[0])
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <int>0xbad0bad0
        (<long *>op0)[0] = <long>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cosine_cdf "cosine_cdf"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cosine_invcdf "cosine_invcdf"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cospi "cospi"(double) noexcept nogil
from ._ellip_harm cimport ellip_harmonic as _func_ellip_harmonic
ctypedef double _proto_ellip_harmonic_t(double, double, int, int, double, double, double) noexcept nogil
cdef _proto_ellip_harmonic_t *_proto_ellip_harmonic_t_var = &_func_ellip_harmonic
from ._legacy cimport ellip_harmonic_unsafe as _func_ellip_harmonic_unsafe
ctypedef double _proto_ellip_harmonic_unsafe_t(double, double, double, double, double, double, double) noexcept nogil
cdef _proto_ellip_harmonic_unsafe_t *_proto_ellip_harmonic_unsafe_t_var = &_func_ellip_harmonic_unsafe
from ._factorial cimport _factorial as _func__factorial
ctypedef double _proto__factorial_t(double) noexcept nogil
cdef _proto__factorial_t *_proto__factorial_t_var = &_func__factorial
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_igam_fac "igam_fac"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_kolmogc "kolmogc"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_kolmogci "kolmogci"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_kolmogp "kolmogp"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_lanczos_sum_expg_scaled "lanczos_sum_expg_scaled"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_lgam1p "lgam1p"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_log1pmx "log1pmx"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_riemann_zeta "riemann_zeta"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_scaled_exp1 "scaled_exp1"(double) noexcept nogil
from .sf_error cimport _sf_error_test_function as _func__sf_error_test_function
ctypedef int _proto__sf_error_test_function_t(int) noexcept nogil
cdef _proto__sf_error_test_function_t *_proto__sf_error_test_function_t_var = &_func__sf_error_test_function
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_sinpi "sinpi"(double) noexcept nogil
from ._legacy cimport smirnovc_unsafe as _func_smirnovc_unsafe
ctypedef double _proto_smirnovc_unsafe_t(double, double) noexcept nogil
cdef _proto_smirnovc_unsafe_t *_proto_smirnovc_unsafe_t_var = &_func_smirnovc_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_smirnovc "smirnovc"(int, double) noexcept nogil
from ._legacy cimport smirnovci_unsafe as _func_smirnovci_unsafe
ctypedef double _proto_smirnovci_unsafe_t(double, double) noexcept nogil
cdef _proto_smirnovci_unsafe_t *_proto_smirnovci_unsafe_t_var = &_func_smirnovci_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_smirnovci "smirnovci"(int, double) noexcept nogil
from ._legacy cimport smirnovp_unsafe as _func_smirnovp_unsafe
ctypedef double _proto_smirnovp_unsafe_t(double, double) noexcept nogil
cdef _proto_smirnovp_unsafe_t *_proto_smirnovp_unsafe_t_var = &_func_smirnovp_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_smirnovp "smirnovp"(int, double) noexcept nogil
from ._spherical_bessel cimport spherical_in_complex as _func_spherical_in_complex
ctypedef double complex _proto_spherical_in_complex_t(long, double complex) noexcept nogil
cdef _proto_spherical_in_complex_t *_proto_spherical_in_complex_t_var = &_func_spherical_in_complex
from ._spherical_bessel cimport spherical_in_real as _func_spherical_in_real
ctypedef double _proto_spherical_in_real_t(long, double) noexcept nogil
cdef _proto_spherical_in_real_t *_proto_spherical_in_real_t_var = &_func_spherical_in_real
from ._spherical_bessel cimport spherical_in_d_complex as _func_spherical_in_d_complex
ctypedef double complex _proto_spherical_in_d_complex_t(long, double complex) noexcept nogil
cdef _proto_spherical_in_d_complex_t *_proto_spherical_in_d_complex_t_var = &_func_spherical_in_d_complex
from ._spherical_bessel cimport spherical_in_d_real as _func_spherical_in_d_real
ctypedef double _proto_spherical_in_d_real_t(long, double) noexcept nogil
cdef _proto_spherical_in_d_real_t *_proto_spherical_in_d_real_t_var = &_func_spherical_in_d_real
from ._spherical_bessel cimport spherical_jn_complex as _func_spherical_jn_complex
ctypedef double complex _proto_spherical_jn_complex_t(long, double complex) noexcept nogil
cdef _proto_spherical_jn_complex_t *_proto_spherical_jn_complex_t_var = &_func_spherical_jn_complex
from ._spherical_bessel cimport spherical_jn_real as _func_spherical_jn_real
ctypedef double _proto_spherical_jn_real_t(long, double) noexcept nogil
cdef _proto_spherical_jn_real_t *_proto_spherical_jn_real_t_var = &_func_spherical_jn_real
from ._spherical_bessel cimport spherical_jn_d_complex as _func_spherical_jn_d_complex
ctypedef double complex _proto_spherical_jn_d_complex_t(long, double complex) noexcept nogil
cdef _proto_spherical_jn_d_complex_t *_proto_spherical_jn_d_complex_t_var = &_func_spherical_jn_d_complex
from ._spherical_bessel cimport spherical_jn_d_real as _func_spherical_jn_d_real
ctypedef double _proto_spherical_jn_d_real_t(long, double) noexcept nogil
cdef _proto_spherical_jn_d_real_t *_proto_spherical_jn_d_real_t_var = &_func_spherical_jn_d_real
from ._spherical_bessel cimport spherical_kn_complex as _func_spherical_kn_complex
ctypedef double complex _proto_spherical_kn_complex_t(long, double complex) noexcept nogil
cdef _proto_spherical_kn_complex_t *_proto_spherical_kn_complex_t_var = &_func_spherical_kn_complex
from ._spherical_bessel cimport spherical_kn_real as _func_spherical_kn_real
ctypedef double _proto_spherical_kn_real_t(long, double) noexcept nogil
cdef _proto_spherical_kn_real_t *_proto_spherical_kn_real_t_var = &_func_spherical_kn_real
from ._spherical_bessel cimport spherical_kn_d_complex as _func_spherical_kn_d_complex
ctypedef double complex _proto_spherical_kn_d_complex_t(long, double complex) noexcept nogil
cdef _proto_spherical_kn_d_complex_t *_proto_spherical_kn_d_complex_t_var = &_func_spherical_kn_d_complex
from ._spherical_bessel cimport spherical_kn_d_real as _func_spherical_kn_d_real
ctypedef double _proto_spherical_kn_d_real_t(long, double) noexcept nogil
cdef _proto_spherical_kn_d_real_t *_proto_spherical_kn_d_real_t_var = &_func_spherical_kn_d_real
from ._spherical_bessel cimport spherical_yn_complex as _func_spherical_yn_complex
ctypedef double complex _proto_spherical_yn_complex_t(long, double complex) noexcept nogil
cdef _proto_spherical_yn_complex_t *_proto_spherical_yn_complex_t_var = &_func_spherical_yn_complex
from ._spherical_bessel cimport spherical_yn_real as _func_spherical_yn_real
ctypedef double _proto_spherical_yn_real_t(long, double) noexcept nogil
cdef _proto_spherical_yn_real_t *_proto_spherical_yn_real_t_var = &_func_spherical_yn_real
from ._spherical_bessel cimport spherical_yn_d_complex as _func_spherical_yn_d_complex
ctypedef double complex _proto_spherical_yn_d_complex_t(long, double complex) noexcept nogil
cdef _proto_spherical_yn_d_complex_t *_proto_spherical_yn_d_complex_t_var = &_func_spherical_yn_d_complex
from ._spherical_bessel cimport spherical_yn_d_real as _func_spherical_yn_d_real
ctypedef double _proto_spherical_yn_d_real_t(long, double) noexcept nogil
cdef _proto_spherical_yn_d_real_t *_proto_spherical_yn_d_real_t_var = &_func_spherical_yn_d_real
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_struve_asymp_large_z "struve_asymp_large_z"(double, double, int, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_struve_bessel_series "struve_bessel_series"(double, double, int, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_struve_power_series "struve_power_series"(double, double, int, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_zeta "zeta"(double, double) noexcept nogil
from ._agm cimport agm as _func_agm
ctypedef double _proto_agm_t(double, double) noexcept nogil
cdef _proto_agm_t *_proto_agm_t_var = &_func_agm
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_airy_wrap "airy_wrap"(double, double *, double *, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_cairy_wrap "cairy_wrap"(double complex, double complex *, double complex *, double complex *, double complex *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_cairy_wrap_e "cairy_wrap_e"(double complex, double complex *, double complex *, double complex *, double complex *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_cairy_wrap_e_real "cairy_wrap_e_real"(double, double *, double *, double *, double *) noexcept nogil
from ._legacy cimport bdtr_unsafe as _func_bdtr_unsafe
ctypedef double _proto_bdtr_unsafe_t(double, double, double) noexcept nogil
cdef _proto_bdtr_unsafe_t *_proto_bdtr_unsafe_t_var = &_func_bdtr_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_bdtr "bdtr"(double, int, double) noexcept nogil
from ._legacy cimport bdtrc_unsafe as _func_bdtrc_unsafe
ctypedef double _proto_bdtrc_unsafe_t(double, double, double) noexcept nogil
cdef _proto_bdtrc_unsafe_t *_proto_bdtrc_unsafe_t_var = &_func_bdtrc_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_bdtrc "bdtrc"(double, int, double) noexcept nogil
from ._legacy cimport bdtri_unsafe as _func_bdtri_unsafe
ctypedef double _proto_bdtri_unsafe_t(double, double, double) noexcept nogil
cdef _proto_bdtri_unsafe_t *_proto_bdtri_unsafe_t_var = &_func_bdtri_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_bdtri "bdtri"(double, int, double) noexcept nogil
from ._cdflib_wrappers cimport bdtrik as _func_bdtrik
ctypedef double _proto_bdtrik_t(double, double, double) noexcept nogil
cdef _proto_bdtrik_t *_proto_bdtrik_t_var = &_func_bdtrik
from ._cdflib_wrappers cimport bdtrin as _func_bdtrin
ctypedef double _proto_bdtrin_t(double, double, double) noexcept nogil
cdef _proto_bdtrin_t *_proto_bdtrin_t_var = &_func_bdtrin
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_bei_wrap "bei_wrap"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_beip_wrap "beip_wrap"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_ber_wrap "ber_wrap"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_berp_wrap "berp_wrap"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_besselpoly "besselpoly"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_beta "beta"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_lbeta "lbeta"(double, double) noexcept nogil
from ._boxcox cimport boxcox as _func_boxcox
ctypedef double _proto_boxcox_t(double, double) noexcept nogil
cdef _proto_boxcox_t *_proto_boxcox_t_var = &_func_boxcox
from ._boxcox cimport boxcox1p as _func_boxcox1p
ctypedef double _proto_boxcox1p_t(double, double) noexcept nogil
cdef _proto_boxcox1p_t *_proto_boxcox1p_t_var = &_func_boxcox1p
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_btdtr "btdtr"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_incbi "incbi"(double, double, double) noexcept nogil
from ._cdflib_wrappers cimport btdtria as _func_btdtria
ctypedef double _proto_btdtria_t(double, double, double) noexcept nogil
cdef _proto_btdtria_t *_proto_btdtria_t_var = &_func_btdtria
from ._cdflib_wrappers cimport btdtrib as _func_btdtrib
ctypedef double _proto_btdtrib_t(double, double, double) noexcept nogil
cdef _proto_btdtrib_t *_proto_btdtrib_t_var = &_func_btdtrib
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cbrt "cbrt"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_chdtr "chdtr"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_chdtrc "chdtrc"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_chdtri "chdtri"(double, double) noexcept nogil
from ._cdflib_wrappers cimport chdtriv as _func_chdtriv
ctypedef double _proto_chdtriv_t(double, double) noexcept nogil
cdef _proto_chdtriv_t *_proto_chdtriv_t_var = &_func_chdtriv
from ._cdflib_wrappers cimport chndtr as _func_chndtr
ctypedef double _proto_chndtr_t(double, double, double) noexcept nogil
cdef _proto_chndtr_t *_proto_chndtr_t_var = &_func_chndtr
from ._cdflib_wrappers cimport chndtridf as _func_chndtridf
ctypedef double _proto_chndtridf_t(double, double, double) noexcept nogil
cdef _proto_chndtridf_t *_proto_chndtridf_t_var = &_func_chndtridf
from ._cdflib_wrappers cimport chndtrinc as _func_chndtrinc
ctypedef double _proto_chndtrinc_t(double, double, double) noexcept nogil
cdef _proto_chndtrinc_t *_proto_chndtrinc_t_var = &_func_chndtrinc
from ._cdflib_wrappers cimport chndtrix as _func_chndtrix
ctypedef double _proto_chndtrix_t(double, double, double) noexcept nogil
cdef _proto_chndtrix_t *_proto_chndtrix_t_var = &_func_chndtrix
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cosdg "cosdg"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cosm1 "cosm1"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cotdg "cotdg"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_ellpe "ellpe"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_ellie "ellie"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_ellpj "ellpj"(double, double, double *, double *, double *, double *) noexcept nogil
from ._ellipk cimport ellipk as _func_ellipk
ctypedef double _proto_ellipk_t(double) noexcept nogil
cdef _proto_ellipk_t *_proto_ellipk_t_var = &_func_ellipk
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_ellik "ellik"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_ellpk "ellpk"(double) noexcept nogil
from ._convex_analysis cimport entr as _func_entr
ctypedef double _proto_entr_t(double) noexcept nogil
cdef _proto_entr_t *_proto_entr_t_var = &_func_entr
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_erf "erf"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_erfc "erfc"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_erfcinv "erfcinv"(double) noexcept nogil
from .orthogonal_eval cimport eval_chebyc as _func_eval_chebyc
ctypedef double complex _proto_eval_chebyc_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_chebyc_double_complex__t *_proto_eval_chebyc_double_complex__t_var = &_func_eval_chebyc[double_complex]
from .orthogonal_eval cimport eval_chebyc as _func_eval_chebyc
ctypedef double _proto_eval_chebyc_double__t(double, double) noexcept nogil
cdef _proto_eval_chebyc_double__t *_proto_eval_chebyc_double__t_var = &_func_eval_chebyc[double]
from .orthogonal_eval cimport eval_chebyc_l as _func_eval_chebyc_l
ctypedef double _proto_eval_chebyc_l_t(long, double) noexcept nogil
cdef _proto_eval_chebyc_l_t *_proto_eval_chebyc_l_t_var = &_func_eval_chebyc_l
from .orthogonal_eval cimport eval_chebys as _func_eval_chebys
ctypedef double complex _proto_eval_chebys_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_chebys_double_complex__t *_proto_eval_chebys_double_complex__t_var = &_func_eval_chebys[double_complex]
from .orthogonal_eval cimport eval_chebys as _func_eval_chebys
ctypedef double _proto_eval_chebys_double__t(double, double) noexcept nogil
cdef _proto_eval_chebys_double__t *_proto_eval_chebys_double__t_var = &_func_eval_chebys[double]
from .orthogonal_eval cimport eval_chebys_l as _func_eval_chebys_l
ctypedef double _proto_eval_chebys_l_t(long, double) noexcept nogil
cdef _proto_eval_chebys_l_t *_proto_eval_chebys_l_t_var = &_func_eval_chebys_l
from .orthogonal_eval cimport eval_chebyt as _func_eval_chebyt
ctypedef double complex _proto_eval_chebyt_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_chebyt_double_complex__t *_proto_eval_chebyt_double_complex__t_var = &_func_eval_chebyt[double_complex]
from .orthogonal_eval cimport eval_chebyt as _func_eval_chebyt
ctypedef double _proto_eval_chebyt_double__t(double, double) noexcept nogil
cdef _proto_eval_chebyt_double__t *_proto_eval_chebyt_double__t_var = &_func_eval_chebyt[double]
from .orthogonal_eval cimport eval_chebyt_l as _func_eval_chebyt_l
ctypedef double _proto_eval_chebyt_l_t(long, double) noexcept nogil
cdef _proto_eval_chebyt_l_t *_proto_eval_chebyt_l_t_var = &_func_eval_chebyt_l
from .orthogonal_eval cimport eval_chebyu as _func_eval_chebyu
ctypedef double complex _proto_eval_chebyu_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_chebyu_double_complex__t *_proto_eval_chebyu_double_complex__t_var = &_func_eval_chebyu[double_complex]
from .orthogonal_eval cimport eval_chebyu as _func_eval_chebyu
ctypedef double _proto_eval_chebyu_double__t(double, double) noexcept nogil
cdef _proto_eval_chebyu_double__t *_proto_eval_chebyu_double__t_var = &_func_eval_chebyu[double]
from .orthogonal_eval cimport eval_chebyu_l as _func_eval_chebyu_l
ctypedef double _proto_eval_chebyu_l_t(long, double) noexcept nogil
cdef _proto_eval_chebyu_l_t *_proto_eval_chebyu_l_t_var = &_func_eval_chebyu_l
from .orthogonal_eval cimport eval_gegenbauer as _func_eval_gegenbauer
ctypedef double complex _proto_eval_gegenbauer_double_complex__t(double, double, double complex) noexcept nogil
cdef _proto_eval_gegenbauer_double_complex__t *_proto_eval_gegenbauer_double_complex__t_var = &_func_eval_gegenbauer[double_complex]
from .orthogonal_eval cimport eval_gegenbauer as _func_eval_gegenbauer
ctypedef double _proto_eval_gegenbauer_double__t(double, double, double) noexcept nogil
cdef _proto_eval_gegenbauer_double__t *_proto_eval_gegenbauer_double__t_var = &_func_eval_gegenbauer[double]
from .orthogonal_eval cimport eval_gegenbauer_l as _func_eval_gegenbauer_l
ctypedef double _proto_eval_gegenbauer_l_t(long, double, double) noexcept nogil
cdef _proto_eval_gegenbauer_l_t *_proto_eval_gegenbauer_l_t_var = &_func_eval_gegenbauer_l
from .orthogonal_eval cimport eval_genlaguerre as _func_eval_genlaguerre
ctypedef double complex _proto_eval_genlaguerre_double_complex__t(double, double, double complex) noexcept nogil
cdef _proto_eval_genlaguerre_double_complex__t *_proto_eval_genlaguerre_double_complex__t_var = &_func_eval_genlaguerre[double_complex]
from .orthogonal_eval cimport eval_genlaguerre as _func_eval_genlaguerre
ctypedef double _proto_eval_genlaguerre_double__t(double, double, double) noexcept nogil
cdef _proto_eval_genlaguerre_double__t *_proto_eval_genlaguerre_double__t_var = &_func_eval_genlaguerre[double]
from .orthogonal_eval cimport eval_genlaguerre_l as _func_eval_genlaguerre_l
ctypedef double _proto_eval_genlaguerre_l_t(long, double, double) noexcept nogil
cdef _proto_eval_genlaguerre_l_t *_proto_eval_genlaguerre_l_t_var = &_func_eval_genlaguerre_l
from .orthogonal_eval cimport eval_hermite as _func_eval_hermite
ctypedef double _proto_eval_hermite_t(long, double) noexcept nogil
cdef _proto_eval_hermite_t *_proto_eval_hermite_t_var = &_func_eval_hermite
from .orthogonal_eval cimport eval_hermitenorm as _func_eval_hermitenorm
ctypedef double _proto_eval_hermitenorm_t(long, double) noexcept nogil
cdef _proto_eval_hermitenorm_t *_proto_eval_hermitenorm_t_var = &_func_eval_hermitenorm
from .orthogonal_eval cimport eval_jacobi as _func_eval_jacobi
ctypedef double complex _proto_eval_jacobi_double_complex__t(double, double, double, double complex) noexcept nogil
cdef _proto_eval_jacobi_double_complex__t *_proto_eval_jacobi_double_complex__t_var = &_func_eval_jacobi[double_complex]
from .orthogonal_eval cimport eval_jacobi as _func_eval_jacobi
ctypedef double _proto_eval_jacobi_double__t(double, double, double, double) noexcept nogil
cdef _proto_eval_jacobi_double__t *_proto_eval_jacobi_double__t_var = &_func_eval_jacobi[double]
from .orthogonal_eval cimport eval_jacobi_l as _func_eval_jacobi_l
ctypedef double _proto_eval_jacobi_l_t(long, double, double, double) noexcept nogil
cdef _proto_eval_jacobi_l_t *_proto_eval_jacobi_l_t_var = &_func_eval_jacobi_l
from .orthogonal_eval cimport eval_laguerre as _func_eval_laguerre
ctypedef double complex _proto_eval_laguerre_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_laguerre_double_complex__t *_proto_eval_laguerre_double_complex__t_var = &_func_eval_laguerre[double_complex]
from .orthogonal_eval cimport eval_laguerre as _func_eval_laguerre
ctypedef double _proto_eval_laguerre_double__t(double, double) noexcept nogil
cdef _proto_eval_laguerre_double__t *_proto_eval_laguerre_double__t_var = &_func_eval_laguerre[double]
from .orthogonal_eval cimport eval_laguerre_l as _func_eval_laguerre_l
ctypedef double _proto_eval_laguerre_l_t(long, double) noexcept nogil
cdef _proto_eval_laguerre_l_t *_proto_eval_laguerre_l_t_var = &_func_eval_laguerre_l
from .orthogonal_eval cimport eval_legendre as _func_eval_legendre
ctypedef double complex _proto_eval_legendre_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_legendre_double_complex__t *_proto_eval_legendre_double_complex__t_var = &_func_eval_legendre[double_complex]
from .orthogonal_eval cimport eval_legendre as _func_eval_legendre
ctypedef double _proto_eval_legendre_double__t(double, double) noexcept nogil
cdef _proto_eval_legendre_double__t *_proto_eval_legendre_double__t_var = &_func_eval_legendre[double]
from .orthogonal_eval cimport eval_legendre_l as _func_eval_legendre_l
ctypedef double _proto_eval_legendre_l_t(long, double) noexcept nogil
cdef _proto_eval_legendre_l_t *_proto_eval_legendre_l_t_var = &_func_eval_legendre_l
from .orthogonal_eval cimport eval_sh_chebyt as _func_eval_sh_chebyt
ctypedef double complex _proto_eval_sh_chebyt_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_sh_chebyt_double_complex__t *_proto_eval_sh_chebyt_double_complex__t_var = &_func_eval_sh_chebyt[double_complex]
from .orthogonal_eval cimport eval_sh_chebyt as _func_eval_sh_chebyt
ctypedef double _proto_eval_sh_chebyt_double__t(double, double) noexcept nogil
cdef _proto_eval_sh_chebyt_double__t *_proto_eval_sh_chebyt_double__t_var = &_func_eval_sh_chebyt[double]
from .orthogonal_eval cimport eval_sh_chebyt_l as _func_eval_sh_chebyt_l
ctypedef double _proto_eval_sh_chebyt_l_t(long, double) noexcept nogil
cdef _proto_eval_sh_chebyt_l_t *_proto_eval_sh_chebyt_l_t_var = &_func_eval_sh_chebyt_l
from .orthogonal_eval cimport eval_sh_chebyu as _func_eval_sh_chebyu
ctypedef double complex _proto_eval_sh_chebyu_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_sh_chebyu_double_complex__t *_proto_eval_sh_chebyu_double_complex__t_var = &_func_eval_sh_chebyu[double_complex]
from .orthogonal_eval cimport eval_sh_chebyu as _func_eval_sh_chebyu
ctypedef double _proto_eval_sh_chebyu_double__t(double, double) noexcept nogil
cdef _proto_eval_sh_chebyu_double__t *_proto_eval_sh_chebyu_double__t_var = &_func_eval_sh_chebyu[double]
from .orthogonal_eval cimport eval_sh_chebyu_l as _func_eval_sh_chebyu_l
ctypedef double _proto_eval_sh_chebyu_l_t(long, double) noexcept nogil
cdef _proto_eval_sh_chebyu_l_t *_proto_eval_sh_chebyu_l_t_var = &_func_eval_sh_chebyu_l
from .orthogonal_eval cimport eval_sh_jacobi as _func_eval_sh_jacobi
ctypedef double complex _proto_eval_sh_jacobi_double_complex__t(double, double, double, double complex) noexcept nogil
cdef _proto_eval_sh_jacobi_double_complex__t *_proto_eval_sh_jacobi_double_complex__t_var = &_func_eval_sh_jacobi[double_complex]
from .orthogonal_eval cimport eval_sh_jacobi as _func_eval_sh_jacobi
ctypedef double _proto_eval_sh_jacobi_double__t(double, double, double, double) noexcept nogil
cdef _proto_eval_sh_jacobi_double__t *_proto_eval_sh_jacobi_double__t_var = &_func_eval_sh_jacobi[double]
from .orthogonal_eval cimport eval_sh_jacobi_l as _func_eval_sh_jacobi_l
ctypedef double _proto_eval_sh_jacobi_l_t(long, double, double, double) noexcept nogil
cdef _proto_eval_sh_jacobi_l_t *_proto_eval_sh_jacobi_l_t_var = &_func_eval_sh_jacobi_l
from .orthogonal_eval cimport eval_sh_legendre as _func_eval_sh_legendre
ctypedef double complex _proto_eval_sh_legendre_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_sh_legendre_double_complex__t *_proto_eval_sh_legendre_double_complex__t_var = &_func_eval_sh_legendre[double_complex]
from .orthogonal_eval cimport eval_sh_legendre as _func_eval_sh_legendre
ctypedef double _proto_eval_sh_legendre_double__t(double, double) noexcept nogil
cdef _proto_eval_sh_legendre_double__t *_proto_eval_sh_legendre_double__t_var = &_func_eval_sh_legendre[double]
from .orthogonal_eval cimport eval_sh_legendre_l as _func_eval_sh_legendre_l
ctypedef double _proto_eval_sh_legendre_l_t(long, double) noexcept nogil
cdef _proto_eval_sh_legendre_l_t *_proto_eval_sh_legendre_l_t_var = &_func_eval_sh_legendre_l
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cexp1_wrap "cexp1_wrap"(double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_exp1_wrap "exp1_wrap"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_exp10 "exp10"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_exp2 "exp2"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cexpi_wrap "cexpi_wrap"(double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_expi_wrap "expi_wrap"(double) noexcept nogil
from ._cunity cimport cexpm1 as _func_cexpm1
ctypedef double complex _proto_cexpm1_t(double complex) noexcept nogil
cdef _proto_cexpm1_t *_proto_cexpm1_t_var = &_func_cexpm1
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_expm1 "expm1"(double) noexcept nogil
from ._legacy cimport expn_unsafe as _func_expn_unsafe
ctypedef double _proto_expn_unsafe_t(double, double) noexcept nogil
cdef _proto_expn_unsafe_t *_proto_expn_unsafe_t_var = &_func_expn_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_expn "expn"(int, double) noexcept nogil
from ._exprel cimport exprel as _func_exprel
ctypedef double _proto_exprel_t(double) noexcept nogil
cdef _proto_exprel_t *_proto_exprel_t_var = &_func_exprel
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_fdtr "fdtr"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_fdtrc "fdtrc"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_fdtri "fdtri"(double, double, double) noexcept nogil
from ._cdflib_wrappers cimport fdtridfd as _func_fdtridfd
ctypedef double _proto_fdtridfd_t(double, double, double) noexcept nogil
cdef _proto_fdtridfd_t *_proto_fdtridfd_t_var = &_func_fdtridfd
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_fresnl "fresnl"(double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_cfresnl_wrap "cfresnl_wrap"(double complex, double complex *, double complex *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_Gamma "Gamma"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_igam "igam"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_igamc "igamc"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_igamci "igamci"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_igami "igami"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_lgam "lgam"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_gammasgn "gammasgn"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_gdtr "gdtr"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_gdtrc "gdtrc"(double, double, double) noexcept nogil
from ._cdflib_wrappers cimport gdtria as _func_gdtria
ctypedef double _proto_gdtria_t(double, double, double) noexcept nogil
cdef _proto_gdtria_t *_proto_gdtria_t_var = &_func_gdtria
from ._cdflib_wrappers cimport gdtrib as _func_gdtrib
ctypedef double _proto_gdtrib_t(double, double, double) noexcept nogil
cdef _proto_gdtrib_t *_proto_gdtrib_t_var = &_func_gdtrib
from ._cdflib_wrappers cimport gdtrix as _func_gdtrix
ctypedef double _proto_gdtrix_t(double, double, double) noexcept nogil
cdef _proto_gdtrix_t *_proto_gdtrix_t_var = &_func_gdtrix
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesh_wrap1 "cbesh_wrap1"(double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesh_wrap1_e "cbesh_wrap1_e"(double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesh_wrap2 "cbesh_wrap2"(double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesh_wrap2_e "cbesh_wrap2_e"(double, double complex) noexcept nogil
from ._convex_analysis cimport huber as _func_huber
ctypedef double _proto_huber_t(double, double) noexcept nogil
cdef _proto_huber_t *_proto_huber_t_var = &_func_huber
from ._hyp0f1 cimport _hyp0f1_cmplx as _func__hyp0f1_cmplx
ctypedef double complex _proto__hyp0f1_cmplx_t(double, double complex) noexcept nogil
cdef _proto__hyp0f1_cmplx_t *_proto__hyp0f1_cmplx_t_var = &_func__hyp0f1_cmplx
from ._hyp0f1 cimport _hyp0f1_real as _func__hyp0f1_real
ctypedef double _proto__hyp0f1_real_t(double, double) noexcept nogil
cdef _proto__hyp0f1_real_t *_proto__hyp0f1_real_t_var = &_func__hyp0f1_real
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_chyp1f1_wrap "chyp1f1_wrap"(double, double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_hyp2f1 "hyp2f1"(double, double, double, double) noexcept nogil
from ._hyp2f1 cimport hyp2f1_complex as _func_hyp2f1_complex
ctypedef double complex _proto_hyp2f1_complex_t(double, double, double, double complex) noexcept nogil
cdef _proto_hyp2f1_complex_t *_proto_hyp2f1_complex_t_var = &_func_hyp2f1_complex
from ._hypergeometric cimport hyperu as _func_hyperu
ctypedef double _proto_hyperu_t(double, double, double) noexcept nogil
cdef _proto_hyperu_t *_proto_hyperu_t_var = &_func_hyperu
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_i0 "i0"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_i0e "i0e"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_i1 "i1"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_i1e "i1e"(double) noexcept nogil
from ._boxcox cimport inv_boxcox as _func_inv_boxcox
ctypedef double _proto_inv_boxcox_t(double, double) noexcept nogil
cdef _proto_inv_boxcox_t *_proto_inv_boxcox_t_var = &_func_inv_boxcox
from ._boxcox cimport inv_boxcox1p as _func_inv_boxcox1p
ctypedef double _proto_inv_boxcox1p_t(double, double) noexcept nogil
cdef _proto_inv_boxcox1p_t *_proto_inv_boxcox1p_t_var = &_func_inv_boxcox1p
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_it2i0k0_wrap "it2i0k0_wrap"(double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_it2j0y0_wrap "it2j0y0_wrap"(double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_it2struve0_wrap "it2struve0_wrap"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_itairy_wrap "itairy_wrap"(double, double *, double *, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_it1i0k0_wrap "it1i0k0_wrap"(double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_it1j0y0_wrap "it1j0y0_wrap"(double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_itmodstruve0_wrap "itmodstruve0_wrap"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_itstruve0_wrap "itstruve0_wrap"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesi_wrap "cbesi_wrap"(double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_iv "iv"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesi_wrap_e "cbesi_wrap_e"(double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cbesi_wrap_e_real "cbesi_wrap_e_real"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_j0 "j0"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_j1 "j1"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesj_wrap "cbesj_wrap"(double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cbesj_wrap_real "cbesj_wrap_real"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesj_wrap_e "cbesj_wrap_e"(double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cbesj_wrap_e_real "cbesj_wrap_e_real"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_k0 "k0"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_k0e "k0e"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_k1 "k1"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_k1e "k1e"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_kei_wrap "kei_wrap"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_keip_wrap "keip_wrap"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_kelvin_wrap "kelvin_wrap"(double, double complex *, double complex *, double complex *, double complex *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_ker_wrap "ker_wrap"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_kerp_wrap "kerp_wrap"(double) noexcept nogil
from ._convex_analysis cimport kl_div as _func_kl_div
ctypedef double _proto_kl_div_t(double, double) noexcept nogil
cdef _proto_kl_div_t *_proto_kl_div_t_var = &_func_kl_div
from ._legacy cimport kn_unsafe as _func_kn_unsafe
ctypedef double _proto_kn_unsafe_t(double, double) noexcept nogil
cdef _proto_kn_unsafe_t *_proto_kn_unsafe_t_var = &_func_kn_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cbesk_wrap_real_int "cbesk_wrap_real_int"(int, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_kolmogi "kolmogi"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_kolmogorov "kolmogorov"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesk_wrap "cbesk_wrap"(double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cbesk_wrap_real "cbesk_wrap_real"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesk_wrap_e "cbesk_wrap_e"(double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cbesk_wrap_e_real "cbesk_wrap_e_real"(double, double) noexcept nogil
from ._cunity cimport clog1p as _func_clog1p
ctypedef double complex _proto_clog1p_t(double complex) noexcept nogil
cdef _proto_clog1p_t *_proto_clog1p_t_var = &_func_clog1p
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_log1p "log1p"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_pmv_wrap "pmv_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cem_cva_wrap "cem_cva_wrap"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_sem_cva_wrap "sem_cva_wrap"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_cem_wrap "cem_wrap"(double, double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_mcm1_wrap "mcm1_wrap"(double, double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_mcm2_wrap "mcm2_wrap"(double, double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_msm1_wrap "msm1_wrap"(double, double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_msm2_wrap "msm2_wrap"(double, double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_sem_wrap "sem_wrap"(double, double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_modified_fresnel_minus_wrap "modified_fresnel_minus_wrap"(double, double complex *, double complex *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_modified_fresnel_plus_wrap "modified_fresnel_plus_wrap"(double, double complex *, double complex *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_struve_l "struve_l"(double, double) noexcept nogil
from ._legacy cimport nbdtr_unsafe as _func_nbdtr_unsafe
ctypedef double _proto_nbdtr_unsafe_t(double, double, double) noexcept nogil
cdef _proto_nbdtr_unsafe_t *_proto_nbdtr_unsafe_t_var = &_func_nbdtr_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_nbdtr "nbdtr"(int, int, double) noexcept nogil
from ._legacy cimport nbdtrc_unsafe as _func_nbdtrc_unsafe
ctypedef double _proto_nbdtrc_unsafe_t(double, double, double) noexcept nogil
cdef _proto_nbdtrc_unsafe_t *_proto_nbdtrc_unsafe_t_var = &_func_nbdtrc_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_nbdtrc "nbdtrc"(int, int, double) noexcept nogil
from ._legacy cimport nbdtri_unsafe as _func_nbdtri_unsafe
ctypedef double _proto_nbdtri_unsafe_t(double, double, double) noexcept nogil
cdef _proto_nbdtri_unsafe_t *_proto_nbdtri_unsafe_t_var = &_func_nbdtri_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_nbdtri "nbdtri"(int, int, double) noexcept nogil
from ._cdflib_wrappers cimport nbdtrik as _func_nbdtrik
ctypedef double _proto_nbdtrik_t(double, double, double) noexcept nogil
cdef _proto_nbdtrik_t *_proto_nbdtrik_t_var = &_func_nbdtrik
from ._cdflib_wrappers cimport nbdtrin as _func_nbdtrin
ctypedef double _proto_nbdtrin_t(double, double, double) noexcept nogil
cdef _proto_nbdtrin_t *_proto_nbdtrin_t_var = &_func_nbdtrin
from ._cdflib_wrappers cimport ncfdtr as _func_ncfdtr
ctypedef double _proto_ncfdtr_t(double, double, double, double) noexcept nogil
cdef _proto_ncfdtr_t *_proto_ncfdtr_t_var = &_func_ncfdtr
from ._cdflib_wrappers cimport ncfdtri as _func_ncfdtri
ctypedef double _proto_ncfdtri_t(double, double, double, double) noexcept nogil
cdef _proto_ncfdtri_t *_proto_ncfdtri_t_var = &_func_ncfdtri
from ._cdflib_wrappers cimport ncfdtridfd as _func_ncfdtridfd
ctypedef double _proto_ncfdtridfd_t(double, double, double, double) noexcept nogil
cdef _proto_ncfdtridfd_t *_proto_ncfdtridfd_t_var = &_func_ncfdtridfd
from ._cdflib_wrappers cimport ncfdtridfn as _func_ncfdtridfn
ctypedef double _proto_ncfdtridfn_t(double, double, double, double) noexcept nogil
cdef _proto_ncfdtridfn_t *_proto_ncfdtridfn_t_var = &_func_ncfdtridfn
from ._cdflib_wrappers cimport ncfdtrinc as _func_ncfdtrinc
ctypedef double _proto_ncfdtrinc_t(double, double, double, double) noexcept nogil
cdef _proto_ncfdtrinc_t *_proto_ncfdtrinc_t_var = &_func_ncfdtrinc
from ._cdflib_wrappers cimport nctdtr as _func_nctdtr
ctypedef double _proto_nctdtr_t(double, double, double) noexcept nogil
cdef _proto_nctdtr_t *_proto_nctdtr_t_var = &_func_nctdtr
from ._cdflib_wrappers cimport nctdtridf as _func_nctdtridf
ctypedef double _proto_nctdtridf_t(double, double, double) noexcept nogil
cdef _proto_nctdtridf_t *_proto_nctdtridf_t_var = &_func_nctdtridf
from ._cdflib_wrappers cimport nctdtrinc as _func_nctdtrinc
ctypedef double _proto_nctdtrinc_t(double, double, double) noexcept nogil
cdef _proto_nctdtrinc_t *_proto_nctdtrinc_t_var = &_func_nctdtrinc
from ._cdflib_wrappers cimport nctdtrit as _func_nctdtrit
ctypedef double _proto_nctdtrit_t(double, double, double) noexcept nogil
cdef _proto_nctdtrit_t *_proto_nctdtrit_t_var = &_func_nctdtrit
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_ndtr "ndtr"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_ndtri "ndtri"(double) noexcept nogil
from ._ndtri_exp cimport ndtri_exp as _func_ndtri_exp
ctypedef double _proto_ndtri_exp_t(double) noexcept nogil
cdef _proto_ndtri_exp_t *_proto_ndtri_exp_t_var = &_func_ndtri_exp
from ._cdflib_wrappers cimport nrdtrimn as _func_nrdtrimn
ctypedef double _proto_nrdtrimn_t(double, double, double) noexcept nogil
cdef _proto_nrdtrimn_t *_proto_nrdtrimn_t_var = &_func_nrdtrimn
from ._cdflib_wrappers cimport nrdtrisd as _func_nrdtrisd
ctypedef double _proto_nrdtrisd_t(double, double, double) noexcept nogil
cdef _proto_nrdtrisd_t *_proto_nrdtrisd_t_var = &_func_nrdtrisd
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_oblate_aswfa_nocv_wrap "oblate_aswfa_nocv_wrap"(double, double, double, double, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_oblate_aswfa_wrap "oblate_aswfa_wrap"(double, double, double, double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_oblate_segv_wrap "oblate_segv_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_oblate_radial1_nocv_wrap "oblate_radial1_nocv_wrap"(double, double, double, double, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_oblate_radial1_wrap "oblate_radial1_wrap"(double, double, double, double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_oblate_radial2_nocv_wrap "oblate_radial2_nocv_wrap"(double, double, double, double, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_oblate_radial2_wrap "oblate_radial2_wrap"(double, double, double, double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_owens_t "owens_t"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_pbdv_wrap "pbdv_wrap"(double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_pbvv_wrap "pbvv_wrap"(double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_pbwa_wrap "pbwa_wrap"(double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_pdtr "pdtr"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_pdtrc "pdtrc"(double, double) noexcept nogil
from ._legacy cimport pdtri_unsafe as _func_pdtri_unsafe
ctypedef double _proto_pdtri_unsafe_t(double, double) noexcept nogil
cdef _proto_pdtri_unsafe_t *_proto_pdtri_unsafe_t_var = &_func_pdtri_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_pdtri "pdtri"(int, double) noexcept nogil
from ._cdflib_wrappers cimport pdtrik as _func_pdtrik
ctypedef double _proto_pdtrik_t(double, double) noexcept nogil
cdef _proto_pdtrik_t *_proto_pdtrik_t_var = &_func_pdtrik
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_poch "poch"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_prolate_aswfa_nocv_wrap "prolate_aswfa_nocv_wrap"(double, double, double, double, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_prolate_aswfa_wrap "prolate_aswfa_wrap"(double, double, double, double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_prolate_segv_wrap "prolate_segv_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_prolate_radial1_nocv_wrap "prolate_radial1_nocv_wrap"(double, double, double, double, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_prolate_radial1_wrap "prolate_radial1_wrap"(double, double, double, double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_prolate_radial2_nocv_wrap "prolate_radial2_nocv_wrap"(double, double, double, double, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_prolate_radial2_wrap "prolate_radial2_wrap"(double, double, double, double, double, double *, double *) noexcept nogil
from ._convex_analysis cimport pseudo_huber as _func_pseudo_huber
ctypedef double _proto_pseudo_huber_t(double, double) noexcept nogil
cdef _proto_pseudo_huber_t *_proto_pseudo_huber_t_var = &_func_pseudo_huber
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_radian "radian"(double, double, double) noexcept nogil
from ._convex_analysis cimport rel_entr as _func_rel_entr
ctypedef double _proto_rel_entr_t(double, double) noexcept nogil
cdef _proto_rel_entr_t *_proto_rel_entr_t_var = &_func_rel_entr
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_rgamma "rgamma"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_round "round"(double) noexcept nogil
from ._sici cimport cshichi as _func_cshichi
ctypedef int _proto_cshichi_t(double complex, double complex *, double complex *) noexcept nogil
cdef _proto_cshichi_t *_proto_cshichi_t_var = &_func_cshichi
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_shichi "shichi"(double, double *, double *) noexcept nogil
from ._sici cimport csici as _func_csici
ctypedef int _proto_csici_t(double complex, double complex *, double complex *) noexcept nogil
cdef _proto_csici_t *_proto_csici_t_var = &_func_csici
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_sici "sici"(double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_sindg "sindg"(double) noexcept nogil
from ._legacy cimport smirnov_unsafe as _func_smirnov_unsafe
ctypedef double _proto_smirnov_unsafe_t(double, double) noexcept nogil
cdef _proto_smirnov_unsafe_t *_proto_smirnov_unsafe_t_var = &_func_smirnov_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_smirnov "smirnov"(int, double) noexcept nogil
from ._legacy cimport smirnovi_unsafe as _func_smirnovi_unsafe
ctypedef double _proto_smirnovi_unsafe_t(double, double) noexcept nogil
cdef _proto_smirnovi_unsafe_t *_proto_smirnovi_unsafe_t_var = &_func_smirnovi_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_smirnovi "smirnovi"(int, double) noexcept nogil
from ._spence cimport cspence as _func_cspence
ctypedef double complex _proto_cspence_t(double complex) noexcept nogil
cdef _proto_cspence_t *_proto_cspence_t_var = &_func_cspence
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_spence "spence"(double) noexcept nogil
from ._legacy cimport sph_harmonic_unsafe as _func_sph_harmonic_unsafe
ctypedef double complex _proto_sph_harmonic_unsafe_t(double, double, double, double) noexcept nogil
cdef _proto_sph_harmonic_unsafe_t *_proto_sph_harmonic_unsafe_t_var = &_func_sph_harmonic_unsafe
from .sph_harm cimport sph_harmonic as _func_sph_harmonic
ctypedef double complex _proto_sph_harmonic_t(int, int, double, double) noexcept nogil
cdef _proto_sph_harmonic_t *_proto_sph_harmonic_t_var = &_func_sph_harmonic
from ._cdflib_wrappers cimport stdtr as _func_stdtr
ctypedef double _proto_stdtr_t(double, double) noexcept nogil
cdef _proto_stdtr_t *_proto_stdtr_t_var = &_func_stdtr
from ._cdflib_wrappers cimport stdtridf as _func_stdtridf
ctypedef double _proto_stdtridf_t(double, double) noexcept nogil
cdef _proto_stdtridf_t *_proto_stdtridf_t_var = &_func_stdtridf
from ._cdflib_wrappers cimport stdtrit as _func_stdtrit
ctypedef double _proto_stdtrit_t(double, double) noexcept nogil
cdef _proto_stdtrit_t *_proto_stdtrit_t_var = &_func_stdtrit
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_struve_h "struve_h"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_tandg "tandg"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_tukeylambdacdf "tukeylambdacdf"(double, double) noexcept nogil
from ._wright_bessel cimport wright_bessel_scalar as _func_wright_bessel_scalar
ctypedef double _proto_wright_bessel_scalar_t(double, double, double) noexcept nogil
cdef _proto_wright_bessel_scalar_t *_proto_wright_bessel_scalar_t_var = &_func_wright_bessel_scalar
from ._xlogy cimport xlog1py as _func_xlog1py
ctypedef double _proto_xlog1py_double__t(double, double) noexcept nogil
cdef _proto_xlog1py_double__t *_proto_xlog1py_double__t_var = &_func_xlog1py[double]
from ._xlogy cimport xlog1py as _func_xlog1py
ctypedef double complex _proto_xlog1py_double_complex__t(double complex, double complex) noexcept nogil
cdef _proto_xlog1py_double_complex__t *_proto_xlog1py_double_complex__t_var = &_func_xlog1py[double_complex]
from ._xlogy cimport xlogy as _func_xlogy
ctypedef double _proto_xlogy_double__t(double, double) noexcept nogil
cdef _proto_xlogy_double__t *_proto_xlogy_double__t_var = &_func_xlogy[double]
from ._xlogy cimport xlogy as _func_xlogy
ctypedef double complex _proto_xlogy_double_complex__t(double complex, double complex) noexcept nogil
cdef _proto_xlogy_double_complex__t *_proto_xlogy_double_complex__t_var = &_func_xlogy[double_complex]
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_y0 "y0"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_y1 "y1"(double) noexcept nogil
from ._legacy cimport yn_unsafe as _func_yn_unsafe
ctypedef double _proto_yn_unsafe_t(double, double) noexcept nogil
cdef _proto_yn_unsafe_t *_proto_yn_unsafe_t_var = &_func_yn_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_yn "yn"(int, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesy_wrap "cbesy_wrap"(double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cbesy_wrap_real "cbesy_wrap_real"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesy_wrap_e "cbesy_wrap_e"(double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cbesy_wrap_e_real "cbesy_wrap_e_real"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_zetac "zetac"(double) noexcept nogil
cdef np.PyUFuncGenericFunction ufunc__cosine_cdf_loops[2]
cdef void *ufunc__cosine_cdf_ptr[4]
cdef void *ufunc__cosine_cdf_data[2]
cdef char ufunc__cosine_cdf_types[4]
cdef char *ufunc__cosine_cdf_doc = (
    "_cosine_cdf(x)\n"
    "\n"
    "Cumulative distribution function (CDF) of the cosine distribution::\n"
    "\n"
    "             {             0,              x < -pi\n"
    "    cdf(x) = { (pi + x + sin(x))/(2*pi),   -pi <= x <= pi\n"
    "             {             1,              x > pi\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    `x` must contain real numbers.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The cosine distribution CDF evaluated at `x`.")
ufunc__cosine_cdf_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__cosine_cdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__cosine_cdf_types[0] = <char>NPY_FLOAT
ufunc__cosine_cdf_types[1] = <char>NPY_FLOAT
ufunc__cosine_cdf_types[2] = <char>NPY_DOUBLE
ufunc__cosine_cdf_types[3] = <char>NPY_DOUBLE
ufunc__cosine_cdf_ptr[2*0] = <void*>_func_cosine_cdf
ufunc__cosine_cdf_ptr[2*0+1] = <void*>(<char*>"_cosine_cdf")
ufunc__cosine_cdf_ptr[2*1] = <void*>_func_cosine_cdf
ufunc__cosine_cdf_ptr[2*1+1] = <void*>(<char*>"_cosine_cdf")
ufunc__cosine_cdf_data[0] = &ufunc__cosine_cdf_ptr[2*0]
ufunc__cosine_cdf_data[1] = &ufunc__cosine_cdf_ptr[2*1]
_cosine_cdf = np.PyUFunc_FromFuncAndData(ufunc__cosine_cdf_loops, ufunc__cosine_cdf_data, ufunc__cosine_cdf_types, 2, 1, 1, 0, "_cosine_cdf", ufunc__cosine_cdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__cosine_invcdf_loops[2]
cdef void *ufunc__cosine_invcdf_ptr[4]
cdef void *ufunc__cosine_invcdf_data[2]
cdef char ufunc__cosine_invcdf_types[4]
cdef char *ufunc__cosine_invcdf_doc = (
    "_cosine_invcdf(p)\n"
    "\n"
    "Inverse of the cumulative distribution function (CDF) of the cosine\n"
    "distribution.\n"
    "\n"
    "The CDF of the cosine distribution is::\n"
    "\n"
    "    cdf(x) = (pi + x + sin(x))/(2*pi)\n"
    "\n"
    "This function computes the inverse of cdf(x).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    `p` must contain real numbers in the interval ``0 <= p <= 1``.\n"
    "    `nan` is returned for values of `p` outside the interval [0, 1].\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The inverse of the cosine distribution CDF evaluated at `p`.")
ufunc__cosine_invcdf_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__cosine_invcdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__cosine_invcdf_types[0] = <char>NPY_FLOAT
ufunc__cosine_invcdf_types[1] = <char>NPY_FLOAT
ufunc__cosine_invcdf_types[2] = <char>NPY_DOUBLE
ufunc__cosine_invcdf_types[3] = <char>NPY_DOUBLE
ufunc__cosine_invcdf_ptr[2*0] = <void*>_func_cosine_invcdf
ufunc__cosine_invcdf_ptr[2*0+1] = <void*>(<char*>"_cosine_invcdf")
ufunc__cosine_invcdf_ptr[2*1] = <void*>_func_cosine_invcdf
ufunc__cosine_invcdf_ptr[2*1+1] = <void*>(<char*>"_cosine_invcdf")
ufunc__cosine_invcdf_data[0] = &ufunc__cosine_invcdf_ptr[2*0]
ufunc__cosine_invcdf_data[1] = &ufunc__cosine_invcdf_ptr[2*1]
_cosine_invcdf = np.PyUFunc_FromFuncAndData(ufunc__cosine_invcdf_loops, ufunc__cosine_invcdf_data, ufunc__cosine_invcdf_types, 2, 1, 1, 0, "_cosine_invcdf", ufunc__cosine_invcdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__cospi_loops[4]
cdef void *ufunc__cospi_ptr[8]
cdef void *ufunc__cospi_data[4]
cdef char ufunc__cospi_types[8]
cdef char *ufunc__cospi_doc = (
    "Internal function, do not use.")
ufunc__cospi_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__cospi_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__cospi_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc__cospi_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc__cospi_types[0] = <char>NPY_FLOAT
ufunc__cospi_types[1] = <char>NPY_FLOAT
ufunc__cospi_types[2] = <char>NPY_DOUBLE
ufunc__cospi_types[3] = <char>NPY_DOUBLE
ufunc__cospi_types[4] = <char>NPY_CFLOAT
ufunc__cospi_types[5] = <char>NPY_CFLOAT
ufunc__cospi_types[6] = <char>NPY_CDOUBLE
ufunc__cospi_types[7] = <char>NPY_CDOUBLE
ufunc__cospi_ptr[2*0] = <void*>_func_cospi
ufunc__cospi_ptr[2*0+1] = <void*>(<char*>"_cospi")
ufunc__cospi_ptr[2*1] = <void*>_func_cospi
ufunc__cospi_ptr[2*1+1] = <void*>(<char*>"_cospi")
ufunc__cospi_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_ccospi
ufunc__cospi_ptr[2*2+1] = <void*>(<char*>"_cospi")
ufunc__cospi_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_ccospi
ufunc__cospi_ptr[2*3+1] = <void*>(<char*>"_cospi")
ufunc__cospi_data[0] = &ufunc__cospi_ptr[2*0]
ufunc__cospi_data[1] = &ufunc__cospi_ptr[2*1]
ufunc__cospi_data[2] = &ufunc__cospi_ptr[2*2]
ufunc__cospi_data[3] = &ufunc__cospi_ptr[2*3]
_cospi = np.PyUFunc_FromFuncAndData(ufunc__cospi_loops, ufunc__cospi_data, ufunc__cospi_types, 4, 1, 1, 0, "_cospi", ufunc__cospi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ellip_harm_loops[3]
cdef void *ufunc__ellip_harm_ptr[6]
cdef void *ufunc__ellip_harm_data[3]
cdef char ufunc__ellip_harm_types[24]
cdef char *ufunc__ellip_harm_doc = (
    "Internal function, use `ellip_harm` instead.")
ufunc__ellip_harm_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddddddd__As_fffffff_f
ufunc__ellip_harm_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddiiddd__As_ddllddd_d
ufunc__ellip_harm_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddddddd__As_ddddddd_d
ufunc__ellip_harm_types[0] = <char>NPY_FLOAT
ufunc__ellip_harm_types[1] = <char>NPY_FLOAT
ufunc__ellip_harm_types[2] = <char>NPY_FLOAT
ufunc__ellip_harm_types[3] = <char>NPY_FLOAT
ufunc__ellip_harm_types[4] = <char>NPY_FLOAT
ufunc__ellip_harm_types[5] = <char>NPY_FLOAT
ufunc__ellip_harm_types[6] = <char>NPY_FLOAT
ufunc__ellip_harm_types[7] = <char>NPY_FLOAT
ufunc__ellip_harm_types[8] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[9] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[10] = <char>NPY_LONG
ufunc__ellip_harm_types[11] = <char>NPY_LONG
ufunc__ellip_harm_types[12] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[13] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[14] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[15] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[16] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[17] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[18] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[19] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[20] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[21] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[22] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[23] = <char>NPY_DOUBLE
ufunc__ellip_harm_ptr[2*0] = <void*>_func_ellip_harmonic_unsafe
ufunc__ellip_harm_ptr[2*0+1] = <void*>(<char*>"_ellip_harm")
ufunc__ellip_harm_ptr[2*1] = <void*>_func_ellip_harmonic
ufunc__ellip_harm_ptr[2*1+1] = <void*>(<char*>"_ellip_harm")
ufunc__ellip_harm_ptr[2*2] = <void*>_func_ellip_harmonic_unsafe
ufunc__ellip_harm_ptr[2*2+1] = <void*>(<char*>"_ellip_harm")
ufunc__ellip_harm_data[0] = &ufunc__ellip_harm_ptr[2*0]
ufunc__ellip_harm_data[1] = &ufunc__ellip_harm_ptr[2*1]
ufunc__ellip_harm_data[2] = &ufunc__ellip_harm_ptr[2*2]
_ellip_harm = np.PyUFunc_FromFuncAndData(ufunc__ellip_harm_loops, ufunc__ellip_harm_data, ufunc__ellip_harm_types, 3, 7, 1, 0, "_ellip_harm", ufunc__ellip_harm_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__factorial_loops[2]
cdef void *ufunc__factorial_ptr[4]
cdef void *ufunc__factorial_data[2]
cdef char ufunc__factorial_types[4]
cdef char *ufunc__factorial_doc = (
    "Internal function, do not use.")
ufunc__factorial_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__factorial_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__factorial_types[0] = <char>NPY_FLOAT
ufunc__factorial_types[1] = <char>NPY_FLOAT
ufunc__factorial_types[2] = <char>NPY_DOUBLE
ufunc__factorial_types[3] = <char>NPY_DOUBLE
ufunc__factorial_ptr[2*0] = <void*>_func__factorial
ufunc__factorial_ptr[2*0+1] = <void*>(<char*>"_factorial")
ufunc__factorial_ptr[2*1] = <void*>_func__factorial
ufunc__factorial_ptr[2*1+1] = <void*>(<char*>"_factorial")
ufunc__factorial_data[0] = &ufunc__factorial_ptr[2*0]
ufunc__factorial_data[1] = &ufunc__factorial_ptr[2*1]
_factorial = np.PyUFunc_FromFuncAndData(ufunc__factorial_loops, ufunc__factorial_data, ufunc__factorial_types, 2, 1, 1, 0, "_factorial", ufunc__factorial_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__igam_fac_loops[2]
cdef void *ufunc__igam_fac_ptr[4]
cdef void *ufunc__igam_fac_data[2]
cdef char ufunc__igam_fac_types[6]
cdef char *ufunc__igam_fac_doc = (
    "Internal function, do not use.")
ufunc__igam_fac_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__igam_fac_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__igam_fac_types[0] = <char>NPY_FLOAT
ufunc__igam_fac_types[1] = <char>NPY_FLOAT
ufunc__igam_fac_types[2] = <char>NPY_FLOAT
ufunc__igam_fac_types[3] = <char>NPY_DOUBLE
ufunc__igam_fac_types[4] = <char>NPY_DOUBLE
ufunc__igam_fac_types[5] = <char>NPY_DOUBLE
ufunc__igam_fac_ptr[2*0] = <void*>_func_igam_fac
ufunc__igam_fac_ptr[2*0+1] = <void*>(<char*>"_igam_fac")
ufunc__igam_fac_ptr[2*1] = <void*>_func_igam_fac
ufunc__igam_fac_ptr[2*1+1] = <void*>(<char*>"_igam_fac")
ufunc__igam_fac_data[0] = &ufunc__igam_fac_ptr[2*0]
ufunc__igam_fac_data[1] = &ufunc__igam_fac_ptr[2*1]
_igam_fac = np.PyUFunc_FromFuncAndData(ufunc__igam_fac_loops, ufunc__igam_fac_data, ufunc__igam_fac_types, 2, 2, 1, 0, "_igam_fac", ufunc__igam_fac_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__kolmogc_loops[2]
cdef void *ufunc__kolmogc_ptr[4]
cdef void *ufunc__kolmogc_data[2]
cdef char ufunc__kolmogc_types[4]
cdef char *ufunc__kolmogc_doc = (
    "Internal function, do not use.")
ufunc__kolmogc_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__kolmogc_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__kolmogc_types[0] = <char>NPY_FLOAT
ufunc__kolmogc_types[1] = <char>NPY_FLOAT
ufunc__kolmogc_types[2] = <char>NPY_DOUBLE
ufunc__kolmogc_types[3] = <char>NPY_DOUBLE
ufunc__kolmogc_ptr[2*0] = <void*>_func_kolmogc
ufunc__kolmogc_ptr[2*0+1] = <void*>(<char*>"_kolmogc")
ufunc__kolmogc_ptr[2*1] = <void*>_func_kolmogc
ufunc__kolmogc_ptr[2*1+1] = <void*>(<char*>"_kolmogc")
ufunc__kolmogc_data[0] = &ufunc__kolmogc_ptr[2*0]
ufunc__kolmogc_data[1] = &ufunc__kolmogc_ptr[2*1]
_kolmogc = np.PyUFunc_FromFuncAndData(ufunc__kolmogc_loops, ufunc__kolmogc_data, ufunc__kolmogc_types, 2, 1, 1, 0, "_kolmogc", ufunc__kolmogc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__kolmogci_loops[2]
cdef void *ufunc__kolmogci_ptr[4]
cdef void *ufunc__kolmogci_data[2]
cdef char ufunc__kolmogci_types[4]
cdef char *ufunc__kolmogci_doc = (
    "Internal function, do not use.")
ufunc__kolmogci_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__kolmogci_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__kolmogci_types[0] = <char>NPY_FLOAT
ufunc__kolmogci_types[1] = <char>NPY_FLOAT
ufunc__kolmogci_types[2] = <char>NPY_DOUBLE
ufunc__kolmogci_types[3] = <char>NPY_DOUBLE
ufunc__kolmogci_ptr[2*0] = <void*>_func_kolmogci
ufunc__kolmogci_ptr[2*0+1] = <void*>(<char*>"_kolmogci")
ufunc__kolmogci_ptr[2*1] = <void*>_func_kolmogci
ufunc__kolmogci_ptr[2*1+1] = <void*>(<char*>"_kolmogci")
ufunc__kolmogci_data[0] = &ufunc__kolmogci_ptr[2*0]
ufunc__kolmogci_data[1] = &ufunc__kolmogci_ptr[2*1]
_kolmogci = np.PyUFunc_FromFuncAndData(ufunc__kolmogci_loops, ufunc__kolmogci_data, ufunc__kolmogci_types, 2, 1, 1, 0, "_kolmogci", ufunc__kolmogci_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__kolmogp_loops[2]
cdef void *ufunc__kolmogp_ptr[4]
cdef void *ufunc__kolmogp_data[2]
cdef char ufunc__kolmogp_types[4]
cdef char *ufunc__kolmogp_doc = (
    "Internal function, do not use.")
ufunc__kolmogp_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__kolmogp_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__kolmogp_types[0] = <char>NPY_FLOAT
ufunc__kolmogp_types[1] = <char>NPY_FLOAT
ufunc__kolmogp_types[2] = <char>NPY_DOUBLE
ufunc__kolmogp_types[3] = <char>NPY_DOUBLE
ufunc__kolmogp_ptr[2*0] = <void*>_func_kolmogp
ufunc__kolmogp_ptr[2*0+1] = <void*>(<char*>"_kolmogp")
ufunc__kolmogp_ptr[2*1] = <void*>_func_kolmogp
ufunc__kolmogp_ptr[2*1+1] = <void*>(<char*>"_kolmogp")
ufunc__kolmogp_data[0] = &ufunc__kolmogp_ptr[2*0]
ufunc__kolmogp_data[1] = &ufunc__kolmogp_ptr[2*1]
_kolmogp = np.PyUFunc_FromFuncAndData(ufunc__kolmogp_loops, ufunc__kolmogp_data, ufunc__kolmogp_types, 2, 1, 1, 0, "_kolmogp", ufunc__kolmogp_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__lambertw_loops[1]
cdef void *ufunc__lambertw_ptr[2]
cdef void *ufunc__lambertw_data[1]
cdef char ufunc__lambertw_types[4]
cdef char *ufunc__lambertw_doc = (
    "Internal function, use `lambertw` instead.")
ufunc__lambertw_loops[0] = <np.PyUFuncGenericFunction>loop_D_Dld__As_Dld_D
ufunc__lambertw_types[0] = <char>NPY_CDOUBLE
ufunc__lambertw_types[1] = <char>NPY_LONG
ufunc__lambertw_types[2] = <char>NPY_DOUBLE
ufunc__lambertw_types[3] = <char>NPY_CDOUBLE
ufunc__lambertw_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_lambertw_scalar
ufunc__lambertw_ptr[2*0+1] = <void*>(<char*>"_lambertw")
ufunc__lambertw_data[0] = &ufunc__lambertw_ptr[2*0]
_lambertw = np.PyUFunc_FromFuncAndData(ufunc__lambertw_loops, ufunc__lambertw_data, ufunc__lambertw_types, 1, 3, 1, 0, "_lambertw", ufunc__lambertw_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__lanczos_sum_expg_scaled_loops[2]
cdef void *ufunc__lanczos_sum_expg_scaled_ptr[4]
cdef void *ufunc__lanczos_sum_expg_scaled_data[2]
cdef char ufunc__lanczos_sum_expg_scaled_types[4]
cdef char *ufunc__lanczos_sum_expg_scaled_doc = (
    "Internal function, do not use.")
ufunc__lanczos_sum_expg_scaled_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__lanczos_sum_expg_scaled_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__lanczos_sum_expg_scaled_types[0] = <char>NPY_FLOAT
ufunc__lanczos_sum_expg_scaled_types[1] = <char>NPY_FLOAT
ufunc__lanczos_sum_expg_scaled_types[2] = <char>NPY_DOUBLE
ufunc__lanczos_sum_expg_scaled_types[3] = <char>NPY_DOUBLE
ufunc__lanczos_sum_expg_scaled_ptr[2*0] = <void*>_func_lanczos_sum_expg_scaled
ufunc__lanczos_sum_expg_scaled_ptr[2*0+1] = <void*>(<char*>"_lanczos_sum_expg_scaled")
ufunc__lanczos_sum_expg_scaled_ptr[2*1] = <void*>_func_lanczos_sum_expg_scaled
ufunc__lanczos_sum_expg_scaled_ptr[2*1+1] = <void*>(<char*>"_lanczos_sum_expg_scaled")
ufunc__lanczos_sum_expg_scaled_data[0] = &ufunc__lanczos_sum_expg_scaled_ptr[2*0]
ufunc__lanczos_sum_expg_scaled_data[1] = &ufunc__lanczos_sum_expg_scaled_ptr[2*1]
_lanczos_sum_expg_scaled = np.PyUFunc_FromFuncAndData(ufunc__lanczos_sum_expg_scaled_loops, ufunc__lanczos_sum_expg_scaled_data, ufunc__lanczos_sum_expg_scaled_types, 2, 1, 1, 0, "_lanczos_sum_expg_scaled", ufunc__lanczos_sum_expg_scaled_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__lgam1p_loops[2]
cdef void *ufunc__lgam1p_ptr[4]
cdef void *ufunc__lgam1p_data[2]
cdef char ufunc__lgam1p_types[4]
cdef char *ufunc__lgam1p_doc = (
    "Internal function, do not use.")
ufunc__lgam1p_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__lgam1p_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__lgam1p_types[0] = <char>NPY_FLOAT
ufunc__lgam1p_types[1] = <char>NPY_FLOAT
ufunc__lgam1p_types[2] = <char>NPY_DOUBLE
ufunc__lgam1p_types[3] = <char>NPY_DOUBLE
ufunc__lgam1p_ptr[2*0] = <void*>_func_lgam1p
ufunc__lgam1p_ptr[2*0+1] = <void*>(<char*>"_lgam1p")
ufunc__lgam1p_ptr[2*1] = <void*>_func_lgam1p
ufunc__lgam1p_ptr[2*1+1] = <void*>(<char*>"_lgam1p")
ufunc__lgam1p_data[0] = &ufunc__lgam1p_ptr[2*0]
ufunc__lgam1p_data[1] = &ufunc__lgam1p_ptr[2*1]
_lgam1p = np.PyUFunc_FromFuncAndData(ufunc__lgam1p_loops, ufunc__lgam1p_data, ufunc__lgam1p_types, 2, 1, 1, 0, "_lgam1p", ufunc__lgam1p_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__log1pmx_loops[2]
cdef void *ufunc__log1pmx_ptr[4]
cdef void *ufunc__log1pmx_data[2]
cdef char ufunc__log1pmx_types[4]
cdef char *ufunc__log1pmx_doc = (
    "Internal function, do not use.")
ufunc__log1pmx_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__log1pmx_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__log1pmx_types[0] = <char>NPY_FLOAT
ufunc__log1pmx_types[1] = <char>NPY_FLOAT
ufunc__log1pmx_types[2] = <char>NPY_DOUBLE
ufunc__log1pmx_types[3] = <char>NPY_DOUBLE
ufunc__log1pmx_ptr[2*0] = <void*>_func_log1pmx
ufunc__log1pmx_ptr[2*0+1] = <void*>(<char*>"_log1pmx")
ufunc__log1pmx_ptr[2*1] = <void*>_func_log1pmx
ufunc__log1pmx_ptr[2*1+1] = <void*>(<char*>"_log1pmx")
ufunc__log1pmx_data[0] = &ufunc__log1pmx_ptr[2*0]
ufunc__log1pmx_data[1] = &ufunc__log1pmx_ptr[2*1]
_log1pmx = np.PyUFunc_FromFuncAndData(ufunc__log1pmx_loops, ufunc__log1pmx_data, ufunc__log1pmx_types, 2, 1, 1, 0, "_log1pmx", ufunc__log1pmx_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__riemann_zeta_loops[2]
cdef void *ufunc__riemann_zeta_ptr[4]
cdef void *ufunc__riemann_zeta_data[2]
cdef char ufunc__riemann_zeta_types[4]
cdef char *ufunc__riemann_zeta_doc = (
    "Internal function, use `zeta` instead.")
ufunc__riemann_zeta_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__riemann_zeta_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__riemann_zeta_types[0] = <char>NPY_FLOAT
ufunc__riemann_zeta_types[1] = <char>NPY_FLOAT
ufunc__riemann_zeta_types[2] = <char>NPY_DOUBLE
ufunc__riemann_zeta_types[3] = <char>NPY_DOUBLE
ufunc__riemann_zeta_ptr[2*0] = <void*>_func_riemann_zeta
ufunc__riemann_zeta_ptr[2*0+1] = <void*>(<char*>"_riemann_zeta")
ufunc__riemann_zeta_ptr[2*1] = <void*>_func_riemann_zeta
ufunc__riemann_zeta_ptr[2*1+1] = <void*>(<char*>"_riemann_zeta")
ufunc__riemann_zeta_data[0] = &ufunc__riemann_zeta_ptr[2*0]
ufunc__riemann_zeta_data[1] = &ufunc__riemann_zeta_ptr[2*1]
_riemann_zeta = np.PyUFunc_FromFuncAndData(ufunc__riemann_zeta_loops, ufunc__riemann_zeta_data, ufunc__riemann_zeta_types, 2, 1, 1, 0, "_riemann_zeta", ufunc__riemann_zeta_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__scaled_exp1_loops[2]
cdef void *ufunc__scaled_exp1_ptr[4]
cdef void *ufunc__scaled_exp1_data[2]
cdef char ufunc__scaled_exp1_types[4]
cdef char *ufunc__scaled_exp1_doc = (
    "_scaled_exp1(x, out=None):\n"
    "\n"
    "Compute the scaled exponential integral.\n"
    "\n"
    "This is a private function, subject to change or removal with no\n"
    "deprecation.\n"
    "\n"
    "This function computes F(x), where F is the factor remaining in E_1(x)\n"
    "when exp(-x)/x is factored out.  That is,::\n"
    "\n"
    "    E_1(x) = exp(-x)/x * F(x)\n"
    "\n"
    "or\n"
    "\n"
    "    F(x) = x * exp(x) * E_1(x)\n"
    "\n"
    "The function is defined for real x >= 0.  For x < 0, nan is returned.\n"
    "\n"
    "F has the properties:\n"
    "\n"
    "* F(0) = 0\n"
    "* F(x) is increasing on [0, inf).\n"
    "* The limit as x goes to infinity of F(x) is 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x: array_like\n"
    "    The input values. Must be real.  The implementation is limited to\n"
    "    double precision floating point, so other types will be cast to\n"
    "    to double precision.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the scaled exponential integral.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "exp1 : exponential integral E_1\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import _scaled_exp1\n"
    ">>> _scaled_exp1([0, 0.1, 1, 10, 100])")
ufunc__scaled_exp1_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__scaled_exp1_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__scaled_exp1_types[0] = <char>NPY_FLOAT
ufunc__scaled_exp1_types[1] = <char>NPY_FLOAT
ufunc__scaled_exp1_types[2] = <char>NPY_DOUBLE
ufunc__scaled_exp1_types[3] = <char>NPY_DOUBLE
ufunc__scaled_exp1_ptr[2*0] = <void*>_func_scaled_exp1
ufunc__scaled_exp1_ptr[2*0+1] = <void*>(<char*>"_scaled_exp1")
ufunc__scaled_exp1_ptr[2*1] = <void*>_func_scaled_exp1
ufunc__scaled_exp1_ptr[2*1+1] = <void*>(<char*>"_scaled_exp1")
ufunc__scaled_exp1_data[0] = &ufunc__scaled_exp1_ptr[2*0]
ufunc__scaled_exp1_data[1] = &ufunc__scaled_exp1_ptr[2*1]
_scaled_exp1 = np.PyUFunc_FromFuncAndData(ufunc__scaled_exp1_loops, ufunc__scaled_exp1_data, ufunc__scaled_exp1_types, 2, 1, 1, 0, "_scaled_exp1", ufunc__scaled_exp1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__sf_error_test_function_loops[1]
cdef void *ufunc__sf_error_test_function_ptr[2]
cdef void *ufunc__sf_error_test_function_data[1]
cdef char ufunc__sf_error_test_function_types[2]
cdef char *ufunc__sf_error_test_function_doc = (
    "Private function; do not use.")
ufunc__sf_error_test_function_loops[0] = <np.PyUFuncGenericFunction>loop_i_i__As_l_l
ufunc__sf_error_test_function_types[0] = <char>NPY_LONG
ufunc__sf_error_test_function_types[1] = <char>NPY_LONG
ufunc__sf_error_test_function_ptr[2*0] = <void*>_func__sf_error_test_function
ufunc__sf_error_test_function_ptr[2*0+1] = <void*>(<char*>"_sf_error_test_function")
ufunc__sf_error_test_function_data[0] = &ufunc__sf_error_test_function_ptr[2*0]
_sf_error_test_function = np.PyUFunc_FromFuncAndData(ufunc__sf_error_test_function_loops, ufunc__sf_error_test_function_data, ufunc__sf_error_test_function_types, 1, 1, 1, 0, "_sf_error_test_function", ufunc__sf_error_test_function_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__sinpi_loops[4]
cdef void *ufunc__sinpi_ptr[8]
cdef void *ufunc__sinpi_data[4]
cdef char ufunc__sinpi_types[8]
cdef char *ufunc__sinpi_doc = (
    "Internal function, do not use.")
ufunc__sinpi_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__sinpi_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__sinpi_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc__sinpi_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc__sinpi_types[0] = <char>NPY_FLOAT
ufunc__sinpi_types[1] = <char>NPY_FLOAT
ufunc__sinpi_types[2] = <char>NPY_DOUBLE
ufunc__sinpi_types[3] = <char>NPY_DOUBLE
ufunc__sinpi_types[4] = <char>NPY_CFLOAT
ufunc__sinpi_types[5] = <char>NPY_CFLOAT
ufunc__sinpi_types[6] = <char>NPY_CDOUBLE
ufunc__sinpi_types[7] = <char>NPY_CDOUBLE
ufunc__sinpi_ptr[2*0] = <void*>_func_sinpi
ufunc__sinpi_ptr[2*0+1] = <void*>(<char*>"_sinpi")
ufunc__sinpi_ptr[2*1] = <void*>_func_sinpi
ufunc__sinpi_ptr[2*1+1] = <void*>(<char*>"_sinpi")
ufunc__sinpi_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_csinpi
ufunc__sinpi_ptr[2*2+1] = <void*>(<char*>"_sinpi")
ufunc__sinpi_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_csinpi
ufunc__sinpi_ptr[2*3+1] = <void*>(<char*>"_sinpi")
ufunc__sinpi_data[0] = &ufunc__sinpi_ptr[2*0]
ufunc__sinpi_data[1] = &ufunc__sinpi_ptr[2*1]
ufunc__sinpi_data[2] = &ufunc__sinpi_ptr[2*2]
ufunc__sinpi_data[3] = &ufunc__sinpi_ptr[2*3]
_sinpi = np.PyUFunc_FromFuncAndData(ufunc__sinpi_loops, ufunc__sinpi_data, ufunc__sinpi_types, 4, 1, 1, 0, "_sinpi", ufunc__sinpi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__smirnovc_loops[3]
cdef void *ufunc__smirnovc_ptr[6]
cdef void *ufunc__smirnovc_data[3]
cdef char ufunc__smirnovc_types[9]
cdef char *ufunc__smirnovc_doc = (
    "_smirnovc(n, d)\n"
    " Internal function, do not use.")
ufunc__smirnovc_loops[0] = <np.PyUFuncGenericFunction>loop_d_id__As_ld_d
ufunc__smirnovc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__smirnovc_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__smirnovc_types[0] = <char>NPY_LONG
ufunc__smirnovc_types[1] = <char>NPY_DOUBLE
ufunc__smirnovc_types[2] = <char>NPY_DOUBLE
ufunc__smirnovc_types[3] = <char>NPY_FLOAT
ufunc__smirnovc_types[4] = <char>NPY_FLOAT
ufunc__smirnovc_types[5] = <char>NPY_FLOAT
ufunc__smirnovc_types[6] = <char>NPY_DOUBLE
ufunc__smirnovc_types[7] = <char>NPY_DOUBLE
ufunc__smirnovc_types[8] = <char>NPY_DOUBLE
ufunc__smirnovc_ptr[2*0] = <void*>_func_smirnovc
ufunc__smirnovc_ptr[2*0+1] = <void*>(<char*>"_smirnovc")
ufunc__smirnovc_ptr[2*1] = <void*>_func_smirnovc_unsafe
ufunc__smirnovc_ptr[2*1+1] = <void*>(<char*>"_smirnovc")
ufunc__smirnovc_ptr[2*2] = <void*>_func_smirnovc_unsafe
ufunc__smirnovc_ptr[2*2+1] = <void*>(<char*>"_smirnovc")
ufunc__smirnovc_data[0] = &ufunc__smirnovc_ptr[2*0]
ufunc__smirnovc_data[1] = &ufunc__smirnovc_ptr[2*1]
ufunc__smirnovc_data[2] = &ufunc__smirnovc_ptr[2*2]
_smirnovc = np.PyUFunc_FromFuncAndData(ufunc__smirnovc_loops, ufunc__smirnovc_data, ufunc__smirnovc_types, 3, 2, 1, 0, "_smirnovc", ufunc__smirnovc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__smirnovci_loops[3]
cdef void *ufunc__smirnovci_ptr[6]
cdef void *ufunc__smirnovci_data[3]
cdef char ufunc__smirnovci_types[9]
cdef char *ufunc__smirnovci_doc = (
    "Internal function, do not use.")
ufunc__smirnovci_loops[0] = <np.PyUFuncGenericFunction>loop_d_id__As_ld_d
ufunc__smirnovci_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__smirnovci_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__smirnovci_types[0] = <char>NPY_LONG
ufunc__smirnovci_types[1] = <char>NPY_DOUBLE
ufunc__smirnovci_types[2] = <char>NPY_DOUBLE
ufunc__smirnovci_types[3] = <char>NPY_FLOAT
ufunc__smirnovci_types[4] = <char>NPY_FLOAT
ufunc__smirnovci_types[5] = <char>NPY_FLOAT
ufunc__smirnovci_types[6] = <char>NPY_DOUBLE
ufunc__smirnovci_types[7] = <char>NPY_DOUBLE
ufunc__smirnovci_types[8] = <char>NPY_DOUBLE
ufunc__smirnovci_ptr[2*0] = <void*>_func_smirnovci
ufunc__smirnovci_ptr[2*0+1] = <void*>(<char*>"_smirnovci")
ufunc__smirnovci_ptr[2*1] = <void*>_func_smirnovci_unsafe
ufunc__smirnovci_ptr[2*1+1] = <void*>(<char*>"_smirnovci")
ufunc__smirnovci_ptr[2*2] = <void*>_func_smirnovci_unsafe
ufunc__smirnovci_ptr[2*2+1] = <void*>(<char*>"_smirnovci")
ufunc__smirnovci_data[0] = &ufunc__smirnovci_ptr[2*0]
ufunc__smirnovci_data[1] = &ufunc__smirnovci_ptr[2*1]
ufunc__smirnovci_data[2] = &ufunc__smirnovci_ptr[2*2]
_smirnovci = np.PyUFunc_FromFuncAndData(ufunc__smirnovci_loops, ufunc__smirnovci_data, ufunc__smirnovci_types, 3, 2, 1, 0, "_smirnovci", ufunc__smirnovci_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__smirnovp_loops[3]
cdef void *ufunc__smirnovp_ptr[6]
cdef void *ufunc__smirnovp_data[3]
cdef char ufunc__smirnovp_types[9]
cdef char *ufunc__smirnovp_doc = (
    "_smirnovp(n, p)\n"
    " Internal function, do not use.")
ufunc__smirnovp_loops[0] = <np.PyUFuncGenericFunction>loop_d_id__As_ld_d
ufunc__smirnovp_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__smirnovp_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__smirnovp_types[0] = <char>NPY_LONG
ufunc__smirnovp_types[1] = <char>NPY_DOUBLE
ufunc__smirnovp_types[2] = <char>NPY_DOUBLE
ufunc__smirnovp_types[3] = <char>NPY_FLOAT
ufunc__smirnovp_types[4] = <char>NPY_FLOAT
ufunc__smirnovp_types[5] = <char>NPY_FLOAT
ufunc__smirnovp_types[6] = <char>NPY_DOUBLE
ufunc__smirnovp_types[7] = <char>NPY_DOUBLE
ufunc__smirnovp_types[8] = <char>NPY_DOUBLE
ufunc__smirnovp_ptr[2*0] = <void*>_func_smirnovp
ufunc__smirnovp_ptr[2*0+1] = <void*>(<char*>"_smirnovp")
ufunc__smirnovp_ptr[2*1] = <void*>_func_smirnovp_unsafe
ufunc__smirnovp_ptr[2*1+1] = <void*>(<char*>"_smirnovp")
ufunc__smirnovp_ptr[2*2] = <void*>_func_smirnovp_unsafe
ufunc__smirnovp_ptr[2*2+1] = <void*>(<char*>"_smirnovp")
ufunc__smirnovp_data[0] = &ufunc__smirnovp_ptr[2*0]
ufunc__smirnovp_data[1] = &ufunc__smirnovp_ptr[2*1]
ufunc__smirnovp_data[2] = &ufunc__smirnovp_ptr[2*2]
_smirnovp = np.PyUFunc_FromFuncAndData(ufunc__smirnovp_loops, ufunc__smirnovp_data, ufunc__smirnovp_types, 3, 2, 1, 0, "_smirnovp", ufunc__smirnovp_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_in_loops[2]
cdef void *ufunc__spherical_in_ptr[4]
cdef void *ufunc__spherical_in_data[2]
cdef char ufunc__spherical_in_types[6]
cdef char *ufunc__spherical_in_doc = (
    "Internal function, use `spherical_in` instead.")
ufunc__spherical_in_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_in_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_in_types[0] = <char>NPY_LONG
ufunc__spherical_in_types[1] = <char>NPY_DOUBLE
ufunc__spherical_in_types[2] = <char>NPY_DOUBLE
ufunc__spherical_in_types[3] = <char>NPY_LONG
ufunc__spherical_in_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_in_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_in_ptr[2*0] = <void*>_func_spherical_in_real
ufunc__spherical_in_ptr[2*0+1] = <void*>(<char*>"_spherical_in")
ufunc__spherical_in_ptr[2*1] = <void*>_func_spherical_in_complex
ufunc__spherical_in_ptr[2*1+1] = <void*>(<char*>"_spherical_in")
ufunc__spherical_in_data[0] = &ufunc__spherical_in_ptr[2*0]
ufunc__spherical_in_data[1] = &ufunc__spherical_in_ptr[2*1]
_spherical_in = np.PyUFunc_FromFuncAndData(ufunc__spherical_in_loops, ufunc__spherical_in_data, ufunc__spherical_in_types, 2, 2, 1, 0, "_spherical_in", ufunc__spherical_in_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_in_d_loops[2]
cdef void *ufunc__spherical_in_d_ptr[4]
cdef void *ufunc__spherical_in_d_data[2]
cdef char ufunc__spherical_in_d_types[6]
cdef char *ufunc__spherical_in_d_doc = (
    "Internal function, use `spherical_in` instead.")
ufunc__spherical_in_d_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_in_d_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_in_d_types[0] = <char>NPY_LONG
ufunc__spherical_in_d_types[1] = <char>NPY_DOUBLE
ufunc__spherical_in_d_types[2] = <char>NPY_DOUBLE
ufunc__spherical_in_d_types[3] = <char>NPY_LONG
ufunc__spherical_in_d_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_in_d_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_in_d_ptr[2*0] = <void*>_func_spherical_in_d_real
ufunc__spherical_in_d_ptr[2*0+1] = <void*>(<char*>"_spherical_in_d")
ufunc__spherical_in_d_ptr[2*1] = <void*>_func_spherical_in_d_complex
ufunc__spherical_in_d_ptr[2*1+1] = <void*>(<char*>"_spherical_in_d")
ufunc__spherical_in_d_data[0] = &ufunc__spherical_in_d_ptr[2*0]
ufunc__spherical_in_d_data[1] = &ufunc__spherical_in_d_ptr[2*1]
_spherical_in_d = np.PyUFunc_FromFuncAndData(ufunc__spherical_in_d_loops, ufunc__spherical_in_d_data, ufunc__spherical_in_d_types, 2, 2, 1, 0, "_spherical_in_d", ufunc__spherical_in_d_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_jn_loops[2]
cdef void *ufunc__spherical_jn_ptr[4]
cdef void *ufunc__spherical_jn_data[2]
cdef char ufunc__spherical_jn_types[6]
cdef char *ufunc__spherical_jn_doc = (
    "Internal function, use `spherical_jn` instead.")
ufunc__spherical_jn_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_jn_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_jn_types[0] = <char>NPY_LONG
ufunc__spherical_jn_types[1] = <char>NPY_DOUBLE
ufunc__spherical_jn_types[2] = <char>NPY_DOUBLE
ufunc__spherical_jn_types[3] = <char>NPY_LONG
ufunc__spherical_jn_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_jn_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_jn_ptr[2*0] = <void*>_func_spherical_jn_real
ufunc__spherical_jn_ptr[2*0+1] = <void*>(<char*>"_spherical_jn")
ufunc__spherical_jn_ptr[2*1] = <void*>_func_spherical_jn_complex
ufunc__spherical_jn_ptr[2*1+1] = <void*>(<char*>"_spherical_jn")
ufunc__spherical_jn_data[0] = &ufunc__spherical_jn_ptr[2*0]
ufunc__spherical_jn_data[1] = &ufunc__spherical_jn_ptr[2*1]
_spherical_jn = np.PyUFunc_FromFuncAndData(ufunc__spherical_jn_loops, ufunc__spherical_jn_data, ufunc__spherical_jn_types, 2, 2, 1, 0, "_spherical_jn", ufunc__spherical_jn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_jn_d_loops[2]
cdef void *ufunc__spherical_jn_d_ptr[4]
cdef void *ufunc__spherical_jn_d_data[2]
cdef char ufunc__spherical_jn_d_types[6]
cdef char *ufunc__spherical_jn_d_doc = (
    "Internal function, use `spherical_jn` instead.")
ufunc__spherical_jn_d_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_jn_d_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_jn_d_types[0] = <char>NPY_LONG
ufunc__spherical_jn_d_types[1] = <char>NPY_DOUBLE
ufunc__spherical_jn_d_types[2] = <char>NPY_DOUBLE
ufunc__spherical_jn_d_types[3] = <char>NPY_LONG
ufunc__spherical_jn_d_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_jn_d_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_jn_d_ptr[2*0] = <void*>_func_spherical_jn_d_real
ufunc__spherical_jn_d_ptr[2*0+1] = <void*>(<char*>"_spherical_jn_d")
ufunc__spherical_jn_d_ptr[2*1] = <void*>_func_spherical_jn_d_complex
ufunc__spherical_jn_d_ptr[2*1+1] = <void*>(<char*>"_spherical_jn_d")
ufunc__spherical_jn_d_data[0] = &ufunc__spherical_jn_d_ptr[2*0]
ufunc__spherical_jn_d_data[1] = &ufunc__spherical_jn_d_ptr[2*1]
_spherical_jn_d = np.PyUFunc_FromFuncAndData(ufunc__spherical_jn_d_loops, ufunc__spherical_jn_d_data, ufunc__spherical_jn_d_types, 2, 2, 1, 0, "_spherical_jn_d", ufunc__spherical_jn_d_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_kn_loops[2]
cdef void *ufunc__spherical_kn_ptr[4]
cdef void *ufunc__spherical_kn_data[2]
cdef char ufunc__spherical_kn_types[6]
cdef char *ufunc__spherical_kn_doc = (
    "Internal function, use `spherical_kn` instead.")
ufunc__spherical_kn_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_kn_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_kn_types[0] = <char>NPY_LONG
ufunc__spherical_kn_types[1] = <char>NPY_DOUBLE
ufunc__spherical_kn_types[2] = <char>NPY_DOUBLE
ufunc__spherical_kn_types[3] = <char>NPY_LONG
ufunc__spherical_kn_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_kn_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_kn_ptr[2*0] = <void*>_func_spherical_kn_real
ufunc__spherical_kn_ptr[2*0+1] = <void*>(<char*>"_spherical_kn")
ufunc__spherical_kn_ptr[2*1] = <void*>_func_spherical_kn_complex
ufunc__spherical_kn_ptr[2*1+1] = <void*>(<char*>"_spherical_kn")
ufunc__spherical_kn_data[0] = &ufunc__spherical_kn_ptr[2*0]
ufunc__spherical_kn_data[1] = &ufunc__spherical_kn_ptr[2*1]
_spherical_kn = np.PyUFunc_FromFuncAndData(ufunc__spherical_kn_loops, ufunc__spherical_kn_data, ufunc__spherical_kn_types, 2, 2, 1, 0, "_spherical_kn", ufunc__spherical_kn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_kn_d_loops[2]
cdef void *ufunc__spherical_kn_d_ptr[4]
cdef void *ufunc__spherical_kn_d_data[2]
cdef char ufunc__spherical_kn_d_types[6]
cdef char *ufunc__spherical_kn_d_doc = (
    "Internal function, use `spherical_kn` instead.")
ufunc__spherical_kn_d_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_kn_d_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_kn_d_types[0] = <char>NPY_LONG
ufunc__spherical_kn_d_types[1] = <char>NPY_DOUBLE
ufunc__spherical_kn_d_types[2] = <char>NPY_DOUBLE
ufunc__spherical_kn_d_types[3] = <char>NPY_LONG
ufunc__spherical_kn_d_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_kn_d_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_kn_d_ptr[2*0] = <void*>_func_spherical_kn_d_real
ufunc__spherical_kn_d_ptr[2*0+1] = <void*>(<char*>"_spherical_kn_d")
ufunc__spherical_kn_d_ptr[2*1] = <void*>_func_spherical_kn_d_complex
ufunc__spherical_kn_d_ptr[2*1+1] = <void*>(<char*>"_spherical_kn_d")
ufunc__spherical_kn_d_data[0] = &ufunc__spherical_kn_d_ptr[2*0]
ufunc__spherical_kn_d_data[1] = &ufunc__spherical_kn_d_ptr[2*1]
_spherical_kn_d = np.PyUFunc_FromFuncAndData(ufunc__spherical_kn_d_loops, ufunc__spherical_kn_d_data, ufunc__spherical_kn_d_types, 2, 2, 1, 0, "_spherical_kn_d", ufunc__spherical_kn_d_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_yn_loops[2]
cdef void *ufunc__spherical_yn_ptr[4]
cdef void *ufunc__spherical_yn_data[2]
cdef char ufunc__spherical_yn_types[6]
cdef char *ufunc__spherical_yn_doc = (
    "Internal function, use `spherical_yn` instead.")
ufunc__spherical_yn_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_yn_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_yn_types[0] = <char>NPY_LONG
ufunc__spherical_yn_types[1] = <char>NPY_DOUBLE
ufunc__spherical_yn_types[2] = <char>NPY_DOUBLE
ufunc__spherical_yn_types[3] = <char>NPY_LONG
ufunc__spherical_yn_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_yn_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_yn_ptr[2*0] = <void*>_func_spherical_yn_real
ufunc__spherical_yn_ptr[2*0+1] = <void*>(<char*>"_spherical_yn")
ufunc__spherical_yn_ptr[2*1] = <void*>_func_spherical_yn_complex
ufunc__spherical_yn_ptr[2*1+1] = <void*>(<char*>"_spherical_yn")
ufunc__spherical_yn_data[0] = &ufunc__spherical_yn_ptr[2*0]
ufunc__spherical_yn_data[1] = &ufunc__spherical_yn_ptr[2*1]
_spherical_yn = np.PyUFunc_FromFuncAndData(ufunc__spherical_yn_loops, ufunc__spherical_yn_data, ufunc__spherical_yn_types, 2, 2, 1, 0, "_spherical_yn", ufunc__spherical_yn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_yn_d_loops[2]
cdef void *ufunc__spherical_yn_d_ptr[4]
cdef void *ufunc__spherical_yn_d_data[2]
cdef char ufunc__spherical_yn_d_types[6]
cdef char *ufunc__spherical_yn_d_doc = (
    "Internal function, use `spherical_yn` instead.")
ufunc__spherical_yn_d_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_yn_d_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_yn_d_types[0] = <char>NPY_LONG
ufunc__spherical_yn_d_types[1] = <char>NPY_DOUBLE
ufunc__spherical_yn_d_types[2] = <char>NPY_DOUBLE
ufunc__spherical_yn_d_types[3] = <char>NPY_LONG
ufunc__spherical_yn_d_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_yn_d_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_yn_d_ptr[2*0] = <void*>_func_spherical_yn_d_real
ufunc__spherical_yn_d_ptr[2*0+1] = <void*>(<char*>"_spherical_yn_d")
ufunc__spherical_yn_d_ptr[2*1] = <void*>_func_spherical_yn_d_complex
ufunc__spherical_yn_d_ptr[2*1+1] = <void*>(<char*>"_spherical_yn_d")
ufunc__spherical_yn_d_data[0] = &ufunc__spherical_yn_d_ptr[2*0]
ufunc__spherical_yn_d_data[1] = &ufunc__spherical_yn_d_ptr[2*1]
_spherical_yn_d = np.PyUFunc_FromFuncAndData(ufunc__spherical_yn_d_loops, ufunc__spherical_yn_d_data, ufunc__spherical_yn_d_types, 2, 2, 1, 0, "_spherical_yn_d", ufunc__spherical_yn_d_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__stirling2_inexact_loops[2]
cdef void *ufunc__stirling2_inexact_ptr[4]
cdef void *ufunc__stirling2_inexact_data[2]
cdef char ufunc__stirling2_inexact_types[6]
cdef char *ufunc__stirling2_inexact_doc = (
    "Internal function, do not use.")
ufunc__stirling2_inexact_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__stirling2_inexact_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__stirling2_inexact_types[0] = <char>NPY_FLOAT
ufunc__stirling2_inexact_types[1] = <char>NPY_FLOAT
ufunc__stirling2_inexact_types[2] = <char>NPY_FLOAT
ufunc__stirling2_inexact_types[3] = <char>NPY_DOUBLE
ufunc__stirling2_inexact_types[4] = <char>NPY_DOUBLE
ufunc__stirling2_inexact_types[5] = <char>NPY_DOUBLE
ufunc__stirling2_inexact_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export__stirling2_inexact
ufunc__stirling2_inexact_ptr[2*0+1] = <void*>(<char*>"_stirling2_inexact")
ufunc__stirling2_inexact_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export__stirling2_inexact
ufunc__stirling2_inexact_ptr[2*1+1] = <void*>(<char*>"_stirling2_inexact")
ufunc__stirling2_inexact_data[0] = &ufunc__stirling2_inexact_ptr[2*0]
ufunc__stirling2_inexact_data[1] = &ufunc__stirling2_inexact_ptr[2*1]
_stirling2_inexact = np.PyUFunc_FromFuncAndData(ufunc__stirling2_inexact_loops, ufunc__stirling2_inexact_data, ufunc__stirling2_inexact_types, 2, 2, 1, 0, "_stirling2_inexact", ufunc__stirling2_inexact_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__struve_asymp_large_z_loops[1]
cdef void *ufunc__struve_asymp_large_z_ptr[2]
cdef void *ufunc__struve_asymp_large_z_data[1]
cdef char ufunc__struve_asymp_large_z_types[5]
cdef char *ufunc__struve_asymp_large_z_doc = (
    "_struve_asymp_large_z(v, z, is_h)\n"
    "\n"
    "Internal function for testing `struve` & `modstruve`\n"
    "\n"
    "Evaluates using asymptotic expansion\n"
    "\n"
    "Returns\n"
    "-------\n"
    "v, err")
ufunc__struve_asymp_large_z_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddi_d_As_ddl_dd
ufunc__struve_asymp_large_z_types[0] = <char>NPY_DOUBLE
ufunc__struve_asymp_large_z_types[1] = <char>NPY_DOUBLE
ufunc__struve_asymp_large_z_types[2] = <char>NPY_LONG
ufunc__struve_asymp_large_z_types[3] = <char>NPY_DOUBLE
ufunc__struve_asymp_large_z_types[4] = <char>NPY_DOUBLE
ufunc__struve_asymp_large_z_ptr[2*0] = <void*>_func_struve_asymp_large_z
ufunc__struve_asymp_large_z_ptr[2*0+1] = <void*>(<char*>"_struve_asymp_large_z")
ufunc__struve_asymp_large_z_data[0] = &ufunc__struve_asymp_large_z_ptr[2*0]
_struve_asymp_large_z = np.PyUFunc_FromFuncAndData(ufunc__struve_asymp_large_z_loops, ufunc__struve_asymp_large_z_data, ufunc__struve_asymp_large_z_types, 1, 3, 2, 0, "_struve_asymp_large_z", ufunc__struve_asymp_large_z_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__struve_bessel_series_loops[1]
cdef void *ufunc__struve_bessel_series_ptr[2]
cdef void *ufunc__struve_bessel_series_data[1]
cdef char ufunc__struve_bessel_series_types[5]
cdef char *ufunc__struve_bessel_series_doc = (
    "_struve_bessel_series(v, z, is_h)\n"
    "\n"
    "Internal function for testing `struve` & `modstruve`\n"
    "\n"
    "Evaluates using Bessel function series\n"
    "\n"
    "Returns\n"
    "-------\n"
    "v, err")
ufunc__struve_bessel_series_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddi_d_As_ddl_dd
ufunc__struve_bessel_series_types[0] = <char>NPY_DOUBLE
ufunc__struve_bessel_series_types[1] = <char>NPY_DOUBLE
ufunc__struve_bessel_series_types[2] = <char>NPY_LONG
ufunc__struve_bessel_series_types[3] = <char>NPY_DOUBLE
ufunc__struve_bessel_series_types[4] = <char>NPY_DOUBLE
ufunc__struve_bessel_series_ptr[2*0] = <void*>_func_struve_bessel_series
ufunc__struve_bessel_series_ptr[2*0+1] = <void*>(<char*>"_struve_bessel_series")
ufunc__struve_bessel_series_data[0] = &ufunc__struve_bessel_series_ptr[2*0]
_struve_bessel_series = np.PyUFunc_FromFuncAndData(ufunc__struve_bessel_series_loops, ufunc__struve_bessel_series_data, ufunc__struve_bessel_series_types, 1, 3, 2, 0, "_struve_bessel_series", ufunc__struve_bessel_series_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__struve_power_series_loops[1]
cdef void *ufunc__struve_power_series_ptr[2]
cdef void *ufunc__struve_power_series_data[1]
cdef char ufunc__struve_power_series_types[5]
cdef char *ufunc__struve_power_series_doc = (
    "_struve_power_series(v, z, is_h)\n"
    "\n"
    "Internal function for testing `struve` & `modstruve`\n"
    "\n"
    "Evaluates using power series\n"
    "\n"
    "Returns\n"
    "-------\n"
    "v, err")
ufunc__struve_power_series_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddi_d_As_ddl_dd
ufunc__struve_power_series_types[0] = <char>NPY_DOUBLE
ufunc__struve_power_series_types[1] = <char>NPY_DOUBLE
ufunc__struve_power_series_types[2] = <char>NPY_LONG
ufunc__struve_power_series_types[3] = <char>NPY_DOUBLE
ufunc__struve_power_series_types[4] = <char>NPY_DOUBLE
ufunc__struve_power_series_ptr[2*0] = <void*>_func_struve_power_series
ufunc__struve_power_series_ptr[2*0+1] = <void*>(<char*>"_struve_power_series")
ufunc__struve_power_series_data[0] = &ufunc__struve_power_series_ptr[2*0]
_struve_power_series = np.PyUFunc_FromFuncAndData(ufunc__struve_power_series_loops, ufunc__struve_power_series_data, ufunc__struve_power_series_types, 1, 3, 2, 0, "_struve_power_series", ufunc__struve_power_series_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__zeta_loops[2]
cdef void *ufunc__zeta_ptr[4]
cdef void *ufunc__zeta_data[2]
cdef char ufunc__zeta_types[6]
cdef char *ufunc__zeta_doc = (
    "_zeta(x, q)\n"
    "\n"
    "Internal function, Hurwitz zeta.")
ufunc__zeta_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__zeta_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__zeta_types[0] = <char>NPY_FLOAT
ufunc__zeta_types[1] = <char>NPY_FLOAT
ufunc__zeta_types[2] = <char>NPY_FLOAT
ufunc__zeta_types[3] = <char>NPY_DOUBLE
ufunc__zeta_types[4] = <char>NPY_DOUBLE
ufunc__zeta_types[5] = <char>NPY_DOUBLE
ufunc__zeta_ptr[2*0] = <void*>_func_zeta
ufunc__zeta_ptr[2*0+1] = <void*>(<char*>"_zeta")
ufunc__zeta_ptr[2*1] = <void*>_func_zeta
ufunc__zeta_ptr[2*1+1] = <void*>(<char*>"_zeta")
ufunc__zeta_data[0] = &ufunc__zeta_ptr[2*0]
ufunc__zeta_data[1] = &ufunc__zeta_ptr[2*1]
_zeta = np.PyUFunc_FromFuncAndData(ufunc__zeta_loops, ufunc__zeta_data, ufunc__zeta_types, 2, 2, 1, 0, "_zeta", ufunc__zeta_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_agm_loops[2]
cdef void *ufunc_agm_ptr[4]
cdef void *ufunc_agm_data[2]
cdef char ufunc_agm_types[6]
cdef char *ufunc_agm_doc = (
    "agm(a, b, out=None)\n"
    "\n"
    "Compute the arithmetic-geometric mean of `a` and `b`.\n"
    "\n"
    "Start with a_0 = a and b_0 = b and iteratively compute::\n"
    "\n"
    "    a_{n+1} = (a_n + b_n)/2\n"
    "    b_{n+1} = sqrt(a_n*b_n)\n"
    "\n"
    "a_n and b_n converge to the same limit as n increases; their common\n"
    "limit is agm(a, b).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "    Real values only. If the values are both negative, the result\n"
    "    is negative. If one value is negative and the other is positive,\n"
    "    `nan` is returned.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The arithmetic-geometric mean of `a` and `b`.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import agm\n"
    ">>> a, b = 24.0, 6.0\n"
    ">>> agm(a, b)\n"
    "13.458171481725614\n"
    "\n"
    "Compare that result to the iteration:\n"
    "\n"
    ">>> while a != b:\n"
    "...     a, b = (a + b)/2, np.sqrt(a*b)\n"
    "...     print(\"a = %19.16f  b=%19.16f\" % (a, b))\n"
    "...\n"
    "a = 15.0000000000000000  b=12.0000000000000000\n"
    "a = 13.5000000000000000  b=13.4164078649987388\n"
    "a = 13.4582039324993694  b=13.4581390309909850\n"
    "a = 13.4581714817451772  b=13.4581714817060547\n"
    "a = 13.4581714817256159  b=13.4581714817256159\n"
    "\n"
    "When array-like arguments are given, broadcasting applies:\n"
    "\n"
    ">>> a = np.array([[1.5], [3], [6]])  # a has shape (3, 1).\n"
    ">>> b = np.array([6, 12, 24, 48])    # b has shape (4,).\n"
    ">>> agm(a, b)\n"
    "array([[  3.36454287,   5.42363427,   9.05798751,  15.53650756],\n"
    "       [  4.37037309,   6.72908574,  10.84726853,  18.11597502],\n"
    "       [  6.        ,   8.74074619,  13.45817148,  21.69453707]])")
ufunc_agm_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_agm_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_agm_types[0] = <char>NPY_FLOAT
ufunc_agm_types[1] = <char>NPY_FLOAT
ufunc_agm_types[2] = <char>NPY_FLOAT
ufunc_agm_types[3] = <char>NPY_DOUBLE
ufunc_agm_types[4] = <char>NPY_DOUBLE
ufunc_agm_types[5] = <char>NPY_DOUBLE
ufunc_agm_ptr[2*0] = <void*>_func_agm
ufunc_agm_ptr[2*0+1] = <void*>(<char*>"agm")
ufunc_agm_ptr[2*1] = <void*>_func_agm
ufunc_agm_ptr[2*1+1] = <void*>(<char*>"agm")
ufunc_agm_data[0] = &ufunc_agm_ptr[2*0]
ufunc_agm_data[1] = &ufunc_agm_ptr[2*1]
agm = np.PyUFunc_FromFuncAndData(ufunc_agm_loops, ufunc_agm_data, ufunc_agm_types, 2, 2, 1, 0, "agm", ufunc_agm_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_airy_loops[4]
cdef void *ufunc_airy_ptr[8]
cdef void *ufunc_airy_data[4]
cdef char ufunc_airy_types[20]
cdef char *ufunc_airy_doc = (
    "airy(z, out=None)\n"
    "\n"
    "Airy functions and their derivatives.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array_like\n"
    "    Real or complex argument.\n"
    "out : tuple of ndarray, optional\n"
    "    Optional output arrays for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "Ai, Aip, Bi, Bip : 4-tuple of scalar or ndarray\n"
    "    Airy functions Ai and Bi, and their derivatives Aip and Bip.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "airye : exponentially scaled Airy functions.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The Airy functions Ai and Bi are two independent solutions of\n"
    "\n"
    ".. math:: y''(x) = x y(x).\n"
    "\n"
    "For real `z` in [-10, 10], the computation is carried out by calling\n"
    "the Cephes [1]_ `airy` routine, which uses power series summation\n"
    "for small `z` and rational minimax approximations for large `z`.\n"
    "\n"
    "Outside this range, the AMOS [2]_ `zairy` and `zbiry` routines are\n"
    "employed.  They are computed using power series for :math:`|z| < 1` and\n"
    "the following relations to modified Bessel functions for larger `z`\n"
    "(where :math:`t \\equiv 2 z^{3/2}/3`):\n"
    "\n"
    ".. math::\n"
    "\n"
    "    Ai(z) = \\frac{1}{\\pi \\sqrt{3}} K_{1/3}(t)\n"
    "\n"
    "    Ai'(z) = -\\frac{z}{\\pi \\sqrt{3}} K_{2/3}(t)\n"
    "\n"
    "    Bi(z) = \\sqrt{\\frac{z}{3}} \\left(I_{-1/3}(t) + I_{1/3}(t) \\right)\n"
    "\n"
    "    Bi'(z) = \\frac{z}{\\sqrt{3}} \\left(I_{-2/3}(t) + I_{2/3}(t)\\right)\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    ".. [2] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Compute the Airy functions on the interval [-15, 5].\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy import special\n"
    ">>> x = np.linspace(-15, 5, 201)\n"
    ">>> ai, aip, bi, bip = special.airy(x)\n"
    "\n"
    "Plot Ai(x) and Bi(x).\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> plt.plot(x, ai, 'r', label='Ai(x)')\n"
    ">>> plt.plot(x, bi, 'b--', label='Bi(x)')\n"
    ">>> plt.ylim(-0.5, 1.0)\n"
    ">>> plt.grid()\n"
    ">>> plt.legend(loc='upper left')\n"
    ">>> plt.show()")
ufunc_airy_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dddd_As_f_ffff
ufunc_airy_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dddd_As_d_dddd
ufunc_airy_loops[2] = <np.PyUFuncGenericFunction>loop_i_D_DDDD_As_F_FFFF
ufunc_airy_loops[3] = <np.PyUFuncGenericFunction>loop_i_D_DDDD_As_D_DDDD
ufunc_airy_types[0] = <char>NPY_FLOAT
ufunc_airy_types[1] = <char>NPY_FLOAT
ufunc_airy_types[2] = <char>NPY_FLOAT
ufunc_airy_types[3] = <char>NPY_FLOAT
ufunc_airy_types[4] = <char>NPY_FLOAT
ufunc_airy_types[5] = <char>NPY_DOUBLE
ufunc_airy_types[6] = <char>NPY_DOUBLE
ufunc_airy_types[7] = <char>NPY_DOUBLE
ufunc_airy_types[8] = <char>NPY_DOUBLE
ufunc_airy_types[9] = <char>NPY_DOUBLE
ufunc_airy_types[10] = <char>NPY_CFLOAT
ufunc_airy_types[11] = <char>NPY_CFLOAT
ufunc_airy_types[12] = <char>NPY_CFLOAT
ufunc_airy_types[13] = <char>NPY_CFLOAT
ufunc_airy_types[14] = <char>NPY_CFLOAT
ufunc_airy_types[15] = <char>NPY_CDOUBLE
ufunc_airy_types[16] = <char>NPY_CDOUBLE
ufunc_airy_types[17] = <char>NPY_CDOUBLE
ufunc_airy_types[18] = <char>NPY_CDOUBLE
ufunc_airy_types[19] = <char>NPY_CDOUBLE
ufunc_airy_ptr[2*0] = <void*>_func_airy_wrap
ufunc_airy_ptr[2*0+1] = <void*>(<char*>"airy")
ufunc_airy_ptr[2*1] = <void*>_func_airy_wrap
ufunc_airy_ptr[2*1+1] = <void*>(<char*>"airy")
ufunc_airy_ptr[2*2] = <void*>_func_cairy_wrap
ufunc_airy_ptr[2*2+1] = <void*>(<char*>"airy")
ufunc_airy_ptr[2*3] = <void*>_func_cairy_wrap
ufunc_airy_ptr[2*3+1] = <void*>(<char*>"airy")
ufunc_airy_data[0] = &ufunc_airy_ptr[2*0]
ufunc_airy_data[1] = &ufunc_airy_ptr[2*1]
ufunc_airy_data[2] = &ufunc_airy_ptr[2*2]
ufunc_airy_data[3] = &ufunc_airy_ptr[2*3]
airy = np.PyUFunc_FromFuncAndData(ufunc_airy_loops, ufunc_airy_data, ufunc_airy_types, 4, 1, 4, 0, "airy", ufunc_airy_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_airye_loops[4]
cdef void *ufunc_airye_ptr[8]
cdef void *ufunc_airye_data[4]
cdef char ufunc_airye_types[20]
cdef char *ufunc_airye_doc = (
    "airye(z, out=None)\n"
    "\n"
    "Exponentially scaled Airy functions and their derivatives.\n"
    "\n"
    "Scaling::\n"
    "\n"
    "    eAi  = Ai  * exp(2.0/3.0*z*sqrt(z))\n"
    "    eAip = Aip * exp(2.0/3.0*z*sqrt(z))\n"
    "    eBi  = Bi  * exp(-abs(2.0/3.0*(z*sqrt(z)).real))\n"
    "    eBip = Bip * exp(-abs(2.0/3.0*(z*sqrt(z)).real))\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array_like\n"
    "    Real or complex argument.\n"
    "out : tuple of ndarray, optional\n"
    "    Optional output arrays for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "eAi, eAip, eBi, eBip : 4-tuple of scalar or ndarray\n"
    "    Exponentially scaled Airy functions eAi and eBi, and their derivatives\n"
    "    eAip and eBip\n"
    "\n"
    "See Also\n"
    "--------\n"
    "airy\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the AMOS [1]_ routines `zairy` and `zbiry`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "We can compute exponentially scaled Airy functions and their derivatives:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import airye\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> z = np.linspace(0, 50, 500)\n"
    ">>> eAi, eAip, eBi, eBip = airye(z)\n"
    ">>> f, ax = plt.subplots(2, 1, sharex=True)\n"
    ">>> for ind, data in enumerate([[eAi, eAip, [\"eAi\", \"eAip\"]],\n"
    "...                             [eBi, eBip, [\"eBi\", \"eBip\"]]]):\n"
    "...     ax[ind].plot(z, data[0], \"-r\", z, data[1], \"-b\")\n"
    "...     ax[ind].legend(data[2])\n"
    "...     ax[ind].grid(True)\n"
    ">>> plt.show()\n"
    "\n"
    "We can compute these using usual non-scaled Airy functions by:\n"
    "\n"
    ">>> from scipy.special import airy\n"
    ">>> Ai, Aip, Bi, Bip = airy(z)\n"
    ">>> np.allclose(eAi, Ai * np.exp(2.0 / 3.0 * z * np.sqrt(z)))\n"
    "True\n"
    ">>> np.allclose(eAip, Aip * np.exp(2.0 / 3.0 * z * np.sqrt(z)))\n"
    "True\n"
    ">>> np.allclose(eBi, Bi * np.exp(-abs(np.real(2.0 / 3.0 * z * np.sqrt(z)))))\n"
    "True\n"
    ">>> np.allclose(eBip, Bip * np.exp(-abs(np.real(2.0 / 3.0 * z * np.sqrt(z)))))\n"
    "True\n"
    "\n"
    "Comparing non-scaled and exponentially scaled ones, the usual non-scaled\n"
    "function quickly underflows for large values, whereas the exponentially\n"
    "scaled function does not.\n"
    "\n"
    ">>> airy(200)\n"
    "(0.0, 0.0, nan, nan)\n"
    ">>> airye(200)\n"
    "(0.07501041684381093, -1.0609012305109042, 0.15003188417418148, 2.1215836725571093)")
ufunc_airye_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dddd_As_f_ffff
ufunc_airye_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dddd_As_d_dddd
ufunc_airye_loops[2] = <np.PyUFuncGenericFunction>loop_i_D_DDDD_As_F_FFFF
ufunc_airye_loops[3] = <np.PyUFuncGenericFunction>loop_i_D_DDDD_As_D_DDDD
ufunc_airye_types[0] = <char>NPY_FLOAT
ufunc_airye_types[1] = <char>NPY_FLOAT
ufunc_airye_types[2] = <char>NPY_FLOAT
ufunc_airye_types[3] = <char>NPY_FLOAT
ufunc_airye_types[4] = <char>NPY_FLOAT
ufunc_airye_types[5] = <char>NPY_DOUBLE
ufunc_airye_types[6] = <char>NPY_DOUBLE
ufunc_airye_types[7] = <char>NPY_DOUBLE
ufunc_airye_types[8] = <char>NPY_DOUBLE
ufunc_airye_types[9] = <char>NPY_DOUBLE
ufunc_airye_types[10] = <char>NPY_CFLOAT
ufunc_airye_types[11] = <char>NPY_CFLOAT
ufunc_airye_types[12] = <char>NPY_CFLOAT
ufunc_airye_types[13] = <char>NPY_CFLOAT
ufunc_airye_types[14] = <char>NPY_CFLOAT
ufunc_airye_types[15] = <char>NPY_CDOUBLE
ufunc_airye_types[16] = <char>NPY_CDOUBLE
ufunc_airye_types[17] = <char>NPY_CDOUBLE
ufunc_airye_types[18] = <char>NPY_CDOUBLE
ufunc_airye_types[19] = <char>NPY_CDOUBLE
ufunc_airye_ptr[2*0] = <void*>_func_cairy_wrap_e_real
ufunc_airye_ptr[2*0+1] = <void*>(<char*>"airye")
ufunc_airye_ptr[2*1] = <void*>_func_cairy_wrap_e_real
ufunc_airye_ptr[2*1+1] = <void*>(<char*>"airye")
ufunc_airye_ptr[2*2] = <void*>_func_cairy_wrap_e
ufunc_airye_ptr[2*2+1] = <void*>(<char*>"airye")
ufunc_airye_ptr[2*3] = <void*>_func_cairy_wrap_e
ufunc_airye_ptr[2*3+1] = <void*>(<char*>"airye")
ufunc_airye_data[0] = &ufunc_airye_ptr[2*0]
ufunc_airye_data[1] = &ufunc_airye_ptr[2*1]
ufunc_airye_data[2] = &ufunc_airye_ptr[2*2]
ufunc_airye_data[3] = &ufunc_airye_ptr[2*3]
airye = np.PyUFunc_FromFuncAndData(ufunc_airye_loops, ufunc_airye_data, ufunc_airye_types, 4, 1, 4, 0, "airye", ufunc_airye_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtr_loops[3]
cdef void *ufunc_bdtr_ptr[6]
cdef void *ufunc_bdtr_data[3]
cdef char ufunc_bdtr_types[12]
cdef char *ufunc_bdtr_doc = (
    "bdtr(k, n, p, out=None)\n"
    "\n"
    "Binomial distribution cumulative distribution function.\n"
    "\n"
    "Sum of the terms 0 through `floor(k)` of the Binomial probability density.\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{bdtr}(k, n, p) =\n"
    "    \\sum_{j=0}^{\\lfloor k \\rfloor} {{n}\\choose{j}} p^j (1-p)^{n-j}\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of successes (double), rounded down to the nearest integer.\n"
    "n : array_like\n"
    "    Number of events (int).\n"
    "p : array_like\n"
    "    Probability of success in a single event (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Probability of `floor(k)` or fewer successes in `n` independent events with\n"
    "    success probabilities of `p`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The terms are not summed directly; instead the regularized incomplete beta\n"
    "function is employed, according to the formula,\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{bdtr}(k, n, p) =\n"
    "    I_{1 - p}(n - \\lfloor k \\rfloor, \\lfloor k \\rfloor + 1).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `bdtr`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/")
ufunc_bdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_did__As_dld_d
ufunc_bdtr_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtr_types[0] = <char>NPY_FLOAT
ufunc_bdtr_types[1] = <char>NPY_FLOAT
ufunc_bdtr_types[2] = <char>NPY_FLOAT
ufunc_bdtr_types[3] = <char>NPY_FLOAT
ufunc_bdtr_types[4] = <char>NPY_DOUBLE
ufunc_bdtr_types[5] = <char>NPY_LONG
ufunc_bdtr_types[6] = <char>NPY_DOUBLE
ufunc_bdtr_types[7] = <char>NPY_DOUBLE
ufunc_bdtr_types[8] = <char>NPY_DOUBLE
ufunc_bdtr_types[9] = <char>NPY_DOUBLE
ufunc_bdtr_types[10] = <char>NPY_DOUBLE
ufunc_bdtr_types[11] = <char>NPY_DOUBLE
ufunc_bdtr_ptr[2*0] = <void*>_func_bdtr_unsafe
ufunc_bdtr_ptr[2*0+1] = <void*>(<char*>"bdtr")
ufunc_bdtr_ptr[2*1] = <void*>_func_bdtr
ufunc_bdtr_ptr[2*1+1] = <void*>(<char*>"bdtr")
ufunc_bdtr_ptr[2*2] = <void*>_func_bdtr_unsafe
ufunc_bdtr_ptr[2*2+1] = <void*>(<char*>"bdtr")
ufunc_bdtr_data[0] = &ufunc_bdtr_ptr[2*0]
ufunc_bdtr_data[1] = &ufunc_bdtr_ptr[2*1]
ufunc_bdtr_data[2] = &ufunc_bdtr_ptr[2*2]
bdtr = np.PyUFunc_FromFuncAndData(ufunc_bdtr_loops, ufunc_bdtr_data, ufunc_bdtr_types, 3, 3, 1, 0, "bdtr", ufunc_bdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtrc_loops[3]
cdef void *ufunc_bdtrc_ptr[6]
cdef void *ufunc_bdtrc_data[3]
cdef char ufunc_bdtrc_types[12]
cdef char *ufunc_bdtrc_doc = (
    "bdtrc(k, n, p, out=None)\n"
    "\n"
    "Binomial distribution survival function.\n"
    "\n"
    "Sum of the terms `floor(k) + 1` through `n` of the binomial probability\n"
    "density,\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{bdtrc}(k, n, p) =\n"
    "    \\sum_{j=\\lfloor k \\rfloor +1}^n {{n}\\choose{j}} p^j (1-p)^{n-j}\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of successes (double), rounded down to nearest integer.\n"
    "n : array_like\n"
    "    Number of events (int)\n"
    "p : array_like\n"
    "    Probability of success in a single event.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Probability of `floor(k) + 1` or more successes in `n` independent\n"
    "    events with success probabilities of `p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "bdtr\n"
    "betainc\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The terms are not summed directly; instead the regularized incomplete beta\n"
    "function is employed, according to the formula,\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{bdtrc}(k, n, p) = I_{p}(\\lfloor k \\rfloor + 1, n - \\lfloor k \\rfloor).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `bdtrc`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/")
ufunc_bdtrc_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtrc_loops[1] = <np.PyUFuncGenericFunction>loop_d_did__As_dld_d
ufunc_bdtrc_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtrc_types[0] = <char>NPY_FLOAT
ufunc_bdtrc_types[1] = <char>NPY_FLOAT
ufunc_bdtrc_types[2] = <char>NPY_FLOAT
ufunc_bdtrc_types[3] = <char>NPY_FLOAT
ufunc_bdtrc_types[4] = <char>NPY_DOUBLE
ufunc_bdtrc_types[5] = <char>NPY_LONG
ufunc_bdtrc_types[6] = <char>NPY_DOUBLE
ufunc_bdtrc_types[7] = <char>NPY_DOUBLE
ufunc_bdtrc_types[8] = <char>NPY_DOUBLE
ufunc_bdtrc_types[9] = <char>NPY_DOUBLE
ufunc_bdtrc_types[10] = <char>NPY_DOUBLE
ufunc_bdtrc_types[11] = <char>NPY_DOUBLE
ufunc_bdtrc_ptr[2*0] = <void*>_func_bdtrc_unsafe
ufunc_bdtrc_ptr[2*0+1] = <void*>(<char*>"bdtrc")
ufunc_bdtrc_ptr[2*1] = <void*>_func_bdtrc
ufunc_bdtrc_ptr[2*1+1] = <void*>(<char*>"bdtrc")
ufunc_bdtrc_ptr[2*2] = <void*>_func_bdtrc_unsafe
ufunc_bdtrc_ptr[2*2+1] = <void*>(<char*>"bdtrc")
ufunc_bdtrc_data[0] = &ufunc_bdtrc_ptr[2*0]
ufunc_bdtrc_data[1] = &ufunc_bdtrc_ptr[2*1]
ufunc_bdtrc_data[2] = &ufunc_bdtrc_ptr[2*2]
bdtrc = np.PyUFunc_FromFuncAndData(ufunc_bdtrc_loops, ufunc_bdtrc_data, ufunc_bdtrc_types, 3, 3, 1, 0, "bdtrc", ufunc_bdtrc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtri_loops[3]
cdef void *ufunc_bdtri_ptr[6]
cdef void *ufunc_bdtri_data[3]
cdef char ufunc_bdtri_types[12]
cdef char *ufunc_bdtri_doc = (
    "bdtri(k, n, y, out=None)\n"
    "\n"
    "Inverse function to `bdtr` with respect to `p`.\n"
    "\n"
    "Finds the event probability `p` such that the sum of the terms 0 through\n"
    "`k` of the binomial probability density is equal to the given cumulative\n"
    "probability `y`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of successes (float), rounded down to the nearest integer.\n"
    "n : array_like\n"
    "    Number of events (float)\n"
    "y : array_like\n"
    "    Cumulative probability (probability of `k` or fewer successes in `n`\n"
    "    events).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "p : scalar or ndarray\n"
    "    The event probability such that `bdtr(\\lfloor k \\rfloor, n, p) = y`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "bdtr\n"
    "betaincinv\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The computation is carried out using the inverse beta integral function\n"
    "and the relation,::\n"
    "\n"
    "    1 - p = betaincinv(n - k, k + 1, y).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `bdtri`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/")
ufunc_bdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_did__As_dld_d
ufunc_bdtri_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtri_types[0] = <char>NPY_FLOAT
ufunc_bdtri_types[1] = <char>NPY_FLOAT
ufunc_bdtri_types[2] = <char>NPY_FLOAT
ufunc_bdtri_types[3] = <char>NPY_FLOAT
ufunc_bdtri_types[4] = <char>NPY_DOUBLE
ufunc_bdtri_types[5] = <char>NPY_LONG
ufunc_bdtri_types[6] = <char>NPY_DOUBLE
ufunc_bdtri_types[7] = <char>NPY_DOUBLE
ufunc_bdtri_types[8] = <char>NPY_DOUBLE
ufunc_bdtri_types[9] = <char>NPY_DOUBLE
ufunc_bdtri_types[10] = <char>NPY_DOUBLE
ufunc_bdtri_types[11] = <char>NPY_DOUBLE
ufunc_bdtri_ptr[2*0] = <void*>_func_bdtri_unsafe
ufunc_bdtri_ptr[2*0+1] = <void*>(<char*>"bdtri")
ufunc_bdtri_ptr[2*1] = <void*>_func_bdtri
ufunc_bdtri_ptr[2*1+1] = <void*>(<char*>"bdtri")
ufunc_bdtri_ptr[2*2] = <void*>_func_bdtri_unsafe
ufunc_bdtri_ptr[2*2+1] = <void*>(<char*>"bdtri")
ufunc_bdtri_data[0] = &ufunc_bdtri_ptr[2*0]
ufunc_bdtri_data[1] = &ufunc_bdtri_ptr[2*1]
ufunc_bdtri_data[2] = &ufunc_bdtri_ptr[2*2]
bdtri = np.PyUFunc_FromFuncAndData(ufunc_bdtri_loops, ufunc_bdtri_data, ufunc_bdtri_types, 3, 3, 1, 0, "bdtri", ufunc_bdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtrik_loops[2]
cdef void *ufunc_bdtrik_ptr[4]
cdef void *ufunc_bdtrik_data[2]
cdef char ufunc_bdtrik_types[8]
cdef char *ufunc_bdtrik_doc = (
    "bdtrik(y, n, p, out=None)\n"
    "\n"
    "Inverse function to `bdtr` with respect to `k`.\n"
    "\n"
    "Finds the number of successes `k` such that the sum of the terms 0 through\n"
    "`k` of the Binomial probability density for `n` events with probability\n"
    "`p` is equal to the given cumulative probability `y`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "y : array_like\n"
    "    Cumulative probability (probability of `k` or fewer successes in `n`\n"
    "    events).\n"
    "n : array_like\n"
    "    Number of events (float).\n"
    "p : array_like\n"
    "    Success probability (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "k : scalar or ndarray\n"
    "    The number of successes `k` such that `bdtr(k, n, p) = y`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "bdtr\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Formula 26.5.24 of [1]_ is used to reduce the binomial distribution to the\n"
    "cumulative incomplete beta distribution.\n"
    "\n"
    "Computation of `k` involves a search for a value that produces the desired\n"
    "value of `y`. The search relies on the monotonicity of `y` with `k`.\n"
    "\n"
    "Wrapper for the CDFLIB [2]_ Fortran routine `cdfbin`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    ".. [2] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.")
ufunc_bdtrik_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtrik_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtrik_types[0] = <char>NPY_FLOAT
ufunc_bdtrik_types[1] = <char>NPY_FLOAT
ufunc_bdtrik_types[2] = <char>NPY_FLOAT
ufunc_bdtrik_types[3] = <char>NPY_FLOAT
ufunc_bdtrik_types[4] = <char>NPY_DOUBLE
ufunc_bdtrik_types[5] = <char>NPY_DOUBLE
ufunc_bdtrik_types[6] = <char>NPY_DOUBLE
ufunc_bdtrik_types[7] = <char>NPY_DOUBLE
ufunc_bdtrik_ptr[2*0] = <void*>_func_bdtrik
ufunc_bdtrik_ptr[2*0+1] = <void*>(<char*>"bdtrik")
ufunc_bdtrik_ptr[2*1] = <void*>_func_bdtrik
ufunc_bdtrik_ptr[2*1+1] = <void*>(<char*>"bdtrik")
ufunc_bdtrik_data[0] = &ufunc_bdtrik_ptr[2*0]
ufunc_bdtrik_data[1] = &ufunc_bdtrik_ptr[2*1]
bdtrik = np.PyUFunc_FromFuncAndData(ufunc_bdtrik_loops, ufunc_bdtrik_data, ufunc_bdtrik_types, 2, 3, 1, 0, "bdtrik", ufunc_bdtrik_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtrin_loops[2]
cdef void *ufunc_bdtrin_ptr[4]
cdef void *ufunc_bdtrin_data[2]
cdef char ufunc_bdtrin_types[8]
cdef char *ufunc_bdtrin_doc = (
    "bdtrin(k, y, p, out=None)\n"
    "\n"
    "Inverse function to `bdtr` with respect to `n`.\n"
    "\n"
    "Finds the number of events `n` such that the sum of the terms 0 through\n"
    "`k` of the Binomial probability density for events with probability `p` is\n"
    "equal to the given cumulative probability `y`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of successes (float).\n"
    "y : array_like\n"
    "    Cumulative probability (probability of `k` or fewer successes in `n`\n"
    "    events).\n"
    "p : array_like\n"
    "    Success probability (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "n : scalar or ndarray\n"
    "    The number of events `n` such that `bdtr(k, n, p) = y`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "bdtr\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Formula 26.5.24 of [1]_ is used to reduce the binomial distribution to the\n"
    "cumulative incomplete beta distribution.\n"
    "\n"
    "Computation of `n` involves a search for a value that produces the desired\n"
    "value of `y`. The search relies on the monotonicity of `y` with `n`.\n"
    "\n"
    "Wrapper for the CDFLIB [2]_ Fortran routine `cdfbin`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    ".. [2] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.")
ufunc_bdtrin_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtrin_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtrin_types[0] = <char>NPY_FLOAT
ufunc_bdtrin_types[1] = <char>NPY_FLOAT
ufunc_bdtrin_types[2] = <char>NPY_FLOAT
ufunc_bdtrin_types[3] = <char>NPY_FLOAT
ufunc_bdtrin_types[4] = <char>NPY_DOUBLE
ufunc_bdtrin_types[5] = <char>NPY_DOUBLE
ufunc_bdtrin_types[6] = <char>NPY_DOUBLE
ufunc_bdtrin_types[7] = <char>NPY_DOUBLE
ufunc_bdtrin_ptr[2*0] = <void*>_func_bdtrin
ufunc_bdtrin_ptr[2*0+1] = <void*>(<char*>"bdtrin")
ufunc_bdtrin_ptr[2*1] = <void*>_func_bdtrin
ufunc_bdtrin_ptr[2*1+1] = <void*>(<char*>"bdtrin")
ufunc_bdtrin_data[0] = &ufunc_bdtrin_ptr[2*0]
ufunc_bdtrin_data[1] = &ufunc_bdtrin_ptr[2*1]
bdtrin = np.PyUFunc_FromFuncAndData(ufunc_bdtrin_loops, ufunc_bdtrin_data, ufunc_bdtrin_types, 2, 3, 1, 0, "bdtrin", ufunc_bdtrin_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bei_loops[2]
cdef void *ufunc_bei_ptr[4]
cdef void *ufunc_bei_data[2]
cdef char ufunc_bei_types[4]
cdef char *ufunc_bei_doc = (
    "bei(x, out=None)\n"
    "\n"
    "Kelvin function bei.\n"
    "\n"
    "Defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\mathrm{bei}(x) = \\Im[J_0(x e^{3 \\pi i / 4})]\n"
    "\n"
    "where :math:`J_0` is the Bessel function of the first kind of\n"
    "order zero (see `jv`). See [dlmf]_ for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real argument.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the Kelvin function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ber : the corresponding real part\n"
    "beip : the derivative of bei\n"
    "jv : Bessel function of the first kind\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST, Digital Library of Mathematical Functions,\n"
    "    https://dlmf.nist.gov/10.61\n"
    "\n"
    "Examples\n"
    "--------\n"
    "It can be expressed using Bessel functions.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    ">>> x = np.array([1.0, 2.0, 3.0, 4.0])\n"
    ">>> sc.jv(0, x * np.exp(3 * np.pi * 1j / 4)).imag\n"
    "array([0.24956604, 0.97229163, 1.93758679, 2.29269032])\n"
    ">>> sc.bei(x)\n"
    "array([0.24956604, 0.97229163, 1.93758679, 2.29269032])")
ufunc_bei_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_bei_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_bei_types[0] = <char>NPY_FLOAT
ufunc_bei_types[1] = <char>NPY_FLOAT
ufunc_bei_types[2] = <char>NPY_DOUBLE
ufunc_bei_types[3] = <char>NPY_DOUBLE
ufunc_bei_ptr[2*0] = <void*>_func_bei_wrap
ufunc_bei_ptr[2*0+1] = <void*>(<char*>"bei")
ufunc_bei_ptr[2*1] = <void*>_func_bei_wrap
ufunc_bei_ptr[2*1+1] = <void*>(<char*>"bei")
ufunc_bei_data[0] = &ufunc_bei_ptr[2*0]
ufunc_bei_data[1] = &ufunc_bei_ptr[2*1]
bei = np.PyUFunc_FromFuncAndData(ufunc_bei_loops, ufunc_bei_data, ufunc_bei_types, 2, 1, 1, 0, "bei", ufunc_bei_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_beip_loops[2]
cdef void *ufunc_beip_ptr[4]
cdef void *ufunc_beip_data[2]
cdef char ufunc_beip_types[4]
cdef char *ufunc_beip_doc = (
    "beip(x, out=None)\n"
    "\n"
    "Derivative of the Kelvin function bei.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real argument.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The values of the derivative of bei.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "bei\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST, Digital Library of Mathematical Functions,\n"
    "    https://dlmf.nist.gov/10#PT5")
ufunc_beip_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_beip_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_beip_types[0] = <char>NPY_FLOAT
ufunc_beip_types[1] = <char>NPY_FLOAT
ufunc_beip_types[2] = <char>NPY_DOUBLE
ufunc_beip_types[3] = <char>NPY_DOUBLE
ufunc_beip_ptr[2*0] = <void*>_func_beip_wrap
ufunc_beip_ptr[2*0+1] = <void*>(<char*>"beip")
ufunc_beip_ptr[2*1] = <void*>_func_beip_wrap
ufunc_beip_ptr[2*1+1] = <void*>(<char*>"beip")
ufunc_beip_data[0] = &ufunc_beip_ptr[2*0]
ufunc_beip_data[1] = &ufunc_beip_ptr[2*1]
beip = np.PyUFunc_FromFuncAndData(ufunc_beip_loops, ufunc_beip_data, ufunc_beip_types, 2, 1, 1, 0, "beip", ufunc_beip_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ber_loops[2]
cdef void *ufunc_ber_ptr[4]
cdef void *ufunc_ber_data[2]
cdef char ufunc_ber_types[4]
cdef char *ufunc_ber_doc = (
    "ber(x, out=None)\n"
    "\n"
    "Kelvin function ber.\n"
    "\n"
    "Defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\mathrm{ber}(x) = \\Re[J_0(x e^{3 \\pi i / 4})]\n"
    "\n"
    "where :math:`J_0` is the Bessel function of the first kind of\n"
    "order zero (see `jv`). See [dlmf]_ for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real argument.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the Kelvin function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "bei : the corresponding real part\n"
    "berp : the derivative of bei\n"
    "jv : Bessel function of the first kind\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST, Digital Library of Mathematical Functions,\n"
    "    https://dlmf.nist.gov/10.61\n"
    "\n"
    "Examples\n"
    "--------\n"
    "It can be expressed using Bessel functions.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    ">>> x = np.array([1.0, 2.0, 3.0, 4.0])\n"
    ">>> sc.jv(0, x * np.exp(3 * np.pi * 1j / 4)).real\n"
    "array([ 0.98438178,  0.75173418, -0.22138025, -2.56341656])\n"
    ">>> sc.ber(x)\n"
    "array([ 0.98438178,  0.75173418, -0.22138025, -2.56341656])")
ufunc_ber_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_ber_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_ber_types[0] = <char>NPY_FLOAT
ufunc_ber_types[1] = <char>NPY_FLOAT
ufunc_ber_types[2] = <char>NPY_DOUBLE
ufunc_ber_types[3] = <char>NPY_DOUBLE
ufunc_ber_ptr[2*0] = <void*>_func_ber_wrap
ufunc_ber_ptr[2*0+1] = <void*>(<char*>"ber")
ufunc_ber_ptr[2*1] = <void*>_func_ber_wrap
ufunc_ber_ptr[2*1+1] = <void*>(<char*>"ber")
ufunc_ber_data[0] = &ufunc_ber_ptr[2*0]
ufunc_ber_data[1] = &ufunc_ber_ptr[2*1]
ber = np.PyUFunc_FromFuncAndData(ufunc_ber_loops, ufunc_ber_data, ufunc_ber_types, 2, 1, 1, 0, "ber", ufunc_ber_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_berp_loops[2]
cdef void *ufunc_berp_ptr[4]
cdef void *ufunc_berp_data[2]
cdef char ufunc_berp_types[4]
cdef char *ufunc_berp_doc = (
    "berp(x, out=None)\n"
    "\n"
    "Derivative of the Kelvin function ber.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real argument.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The values of the derivative of ber.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ber\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST, Digital Library of Mathematical Functions,\n"
    "    https://dlmf.nist.gov/10#PT5")
ufunc_berp_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_berp_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_berp_types[0] = <char>NPY_FLOAT
ufunc_berp_types[1] = <char>NPY_FLOAT
ufunc_berp_types[2] = <char>NPY_DOUBLE
ufunc_berp_types[3] = <char>NPY_DOUBLE
ufunc_berp_ptr[2*0] = <void*>_func_berp_wrap
ufunc_berp_ptr[2*0+1] = <void*>(<char*>"berp")
ufunc_berp_ptr[2*1] = <void*>_func_berp_wrap
ufunc_berp_ptr[2*1+1] = <void*>(<char*>"berp")
ufunc_berp_data[0] = &ufunc_berp_ptr[2*0]
ufunc_berp_data[1] = &ufunc_berp_ptr[2*1]
berp = np.PyUFunc_FromFuncAndData(ufunc_berp_loops, ufunc_berp_data, ufunc_berp_types, 2, 1, 1, 0, "berp", ufunc_berp_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_besselpoly_loops[2]
cdef void *ufunc_besselpoly_ptr[4]
cdef void *ufunc_besselpoly_data[2]
cdef char ufunc_besselpoly_types[8]
cdef char *ufunc_besselpoly_doc = (
    "besselpoly(a, lmb, nu, out=None)\n"
    "\n"
    "Weighted integral of the Bessel function of the first kind.\n"
    "\n"
    "Computes\n"
    "\n"
    ".. math::\n"
    "\n"
    "   \\int_0^1 x^\\lambda J_\\nu(2 a x) \\, dx\n"
    "\n"
    "where :math:`J_\\nu` is a Bessel function and :math:`\\lambda=lmb`,\n"
    ":math:`\\nu=nu`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    Scale factor inside the Bessel function.\n"
    "lmb : array_like\n"
    "    Power of `x`\n"
    "nu : array_like\n"
    "    Order of the Bessel function.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the integral.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Evaluate the function for one parameter set.\n"
    "\n"
    ">>> from scipy.special import besselpoly\n"
    ">>> besselpoly(1, 1, 1)\n"
    "0.24449718372863877\n"
    "\n"
    "Evaluate the function for different scale factors.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> factors = np.array([0., 3., 6.])\n"
    ">>> besselpoly(factors, 1, 1)\n"
    "array([ 0.        , -0.00549029,  0.00140174])\n"
    "\n"
    "Plot the function for varying powers, orders and scales.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> powers = np.linspace(0, 10, 100)\n"
    ">>> orders = [1, 2, 3]\n"
    ">>> scales = [1, 2]\n"
    ">>> all_combinations = [(order, scale) for order in orders\n"
    "...                     for scale in scales]\n"
    ">>> for order, scale in all_combinations:\n"
    "...     ax.plot(powers, besselpoly(scale, powers, order),\n"
    "...             label=rf\"$\\nu={order}, a={scale}$\")\n"
    ">>> ax.legend()\n"
    ">>> ax.set_xlabel(r\"$\\lambda$\")\n"
    ">>> ax.set_ylabel(r\"$\\int_0^1 x^{\\lambda} J_{\\nu}(2ax)\\,dx$\")\n"
    ">>> plt.show()")
ufunc_besselpoly_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_besselpoly_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_besselpoly_types[0] = <char>NPY_FLOAT
ufunc_besselpoly_types[1] = <char>NPY_FLOAT
ufunc_besselpoly_types[2] = <char>NPY_FLOAT
ufunc_besselpoly_types[3] = <char>NPY_FLOAT
ufunc_besselpoly_types[4] = <char>NPY_DOUBLE
ufunc_besselpoly_types[5] = <char>NPY_DOUBLE
ufunc_besselpoly_types[6] = <char>NPY_DOUBLE
ufunc_besselpoly_types[7] = <char>NPY_DOUBLE
ufunc_besselpoly_ptr[2*0] = <void*>_func_besselpoly
ufunc_besselpoly_ptr[2*0+1] = <void*>(<char*>"besselpoly")
ufunc_besselpoly_ptr[2*1] = <void*>_func_besselpoly
ufunc_besselpoly_ptr[2*1+1] = <void*>(<char*>"besselpoly")
ufunc_besselpoly_data[0] = &ufunc_besselpoly_ptr[2*0]
ufunc_besselpoly_data[1] = &ufunc_besselpoly_ptr[2*1]
besselpoly = np.PyUFunc_FromFuncAndData(ufunc_besselpoly_loops, ufunc_besselpoly_data, ufunc_besselpoly_types, 2, 3, 1, 0, "besselpoly", ufunc_besselpoly_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_beta_loops[2]
cdef void *ufunc_beta_ptr[4]
cdef void *ufunc_beta_data[2]
cdef char ufunc_beta_types[6]
cdef char *ufunc_beta_doc = (
    "beta(a, b, out=None)\n"
    "\n"
    "Beta function.\n"
    "\n"
    "This function is defined in [1]_ as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    B(a, b) = \\int_0^1 t^{a-1}(1-t)^{b-1}dt\n"
    "            = \\frac{\\Gamma(a)\\Gamma(b)}{\\Gamma(a+b)},\n"
    "\n"
    "where :math:`\\Gamma` is the gamma function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "    Real-valued arguments\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function result\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the beta function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gamma : the gamma function\n"
    "betainc :  the regularized incomplete beta function\n"
    "betaln : the natural logarithm of the absolute\n"
    "         value of the beta function\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions,\n"
    "       Eq. 5.12.1. https://dlmf.nist.gov/5.12\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "The beta function relates to the gamma function by the\n"
    "definition given above:\n"
    "\n"
    ">>> sc.beta(2, 3)\n"
    "0.08333333333333333\n"
    ">>> sc.gamma(2)*sc.gamma(3)/sc.gamma(2 + 3)\n"
    "0.08333333333333333\n"
    "\n"
    "As this relationship demonstrates, the beta function\n"
    "is symmetric:\n"
    "\n"
    ">>> sc.beta(1.7, 2.4)\n"
    "0.16567527689031739\n"
    ">>> sc.beta(2.4, 1.7)\n"
    "0.16567527689031739\n"
    "\n"
    "This function satisfies :math:`B(1, b) = 1/b`:\n"
    "\n"
    ">>> sc.beta(1, 4)\n"
    "0.25")
ufunc_beta_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_beta_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_beta_types[0] = <char>NPY_FLOAT
ufunc_beta_types[1] = <char>NPY_FLOAT
ufunc_beta_types[2] = <char>NPY_FLOAT
ufunc_beta_types[3] = <char>NPY_DOUBLE
ufunc_beta_types[4] = <char>NPY_DOUBLE
ufunc_beta_types[5] = <char>NPY_DOUBLE
ufunc_beta_ptr[2*0] = <void*>_func_beta
ufunc_beta_ptr[2*0+1] = <void*>(<char*>"beta")
ufunc_beta_ptr[2*1] = <void*>_func_beta
ufunc_beta_ptr[2*1+1] = <void*>(<char*>"beta")
ufunc_beta_data[0] = &ufunc_beta_ptr[2*0]
ufunc_beta_data[1] = &ufunc_beta_ptr[2*1]
beta = np.PyUFunc_FromFuncAndData(ufunc_beta_loops, ufunc_beta_data, ufunc_beta_types, 2, 2, 1, 0, "beta", ufunc_beta_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_betainc_loops[2]
cdef void *ufunc_betainc_ptr[4]
cdef void *ufunc_betainc_data[2]
cdef char ufunc_betainc_types[8]
cdef char *ufunc_betainc_doc = (
    "betainc(a, b, x, out=None)\n"
    "\n"
    "Regularized incomplete beta function.\n"
    "\n"
    "Computes the regularized incomplete beta function, defined as [1]_:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    I_x(a, b) = \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)} \\int_0^x\n"
    "    t^{a-1}(1-t)^{b-1}dt,\n"
    "\n"
    "for :math:`0 \\leq x \\leq 1`.\n"
    "\n"
    "This function is the cumulative distribution function for the beta\n"
    "distribution; its range is [0, 1].\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "       Positive, real-valued parameters\n"
    "x : array_like\n"
    "    Real-valued such that :math:`0 \\leq x \\leq 1`,\n"
    "    the upper limit of integration\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the regularized incomplete beta function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "beta : beta function\n"
    "betaincinv : inverse of the regularized incomplete beta function\n"
    "betaincc : complement of the regularized incomplete beta function\n"
    "scipy.stats.beta : beta distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The term *regularized* in the name of this function refers to the\n"
    "scaling of the function by the gamma function terms shown in the\n"
    "formula.  When not qualified as *regularized*, the name *incomplete\n"
    "beta function* often refers to just the integral expression,\n"
    "without the gamma terms.  One can use the function `beta` from\n"
    "`scipy.special` to get this \"nonregularized\" incomplete beta\n"
    "function by multiplying the result of ``betainc(a, b, x)`` by\n"
    "``beta(a, b)``.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       https://dlmf.nist.gov/8.17\n"
    "\n"
    "Examples\n"
    "--------\n"
    "\n"
    "Let :math:`B(a, b)` be the `beta` function.\n"
    "\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "The coefficient in terms of `gamma` is equal to\n"
    ":math:`1/B(a, b)`. Also, when :math:`x=1`\n"
    "the integral is equal to :math:`B(a, b)`.\n"
    "Therefore, :math:`I_{x=1}(a, b) = 1` for any :math:`a, b`.\n"
    "\n"
    ">>> sc.betainc(0.2, 3.5, 1.0)\n"
    "1.0\n"
    "\n"
    "It satisfies\n"
    ":math:`I_x(a, b) = x^a F(a, 1-b, a+1, x)/ (aB(a, b))`,\n"
    "where :math:`F` is the hypergeometric function `hyp2f1`:\n"
    "\n"
    ">>> a, b, x = 1.4, 3.1, 0.5\n"
    ">>> x**a * sc.hyp2f1(a, 1 - b, a + 1, x)/(a * sc.beta(a, b))\n"
    "0.8148904036225295\n"
    ">>> sc.betainc(a, b, x)\n"
    "0.8148904036225296\n"
    "\n"
    "This functions satisfies the relationship\n"
    ":math:`I_x(a, b) = 1 - I_{1-x}(b, a)`:\n"
    "\n"
    ">>> sc.betainc(2.2, 3.1, 0.4)\n"
    "0.49339638807619446\n"
    ">>> 1 - sc.betainc(3.1, 2.2, 1 - 0.4)\n"
    "0.49339638807619446")
ufunc_betainc_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc_betainc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_betainc_types[0] = <char>NPY_FLOAT
ufunc_betainc_types[1] = <char>NPY_FLOAT
ufunc_betainc_types[2] = <char>NPY_FLOAT
ufunc_betainc_types[3] = <char>NPY_FLOAT
ufunc_betainc_types[4] = <char>NPY_DOUBLE
ufunc_betainc_types[5] = <char>NPY_DOUBLE
ufunc_betainc_types[6] = <char>NPY_DOUBLE
ufunc_betainc_types[7] = <char>NPY_DOUBLE
ufunc_betainc_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ibeta_float
ufunc_betainc_ptr[2*0+1] = <void*>(<char*>"betainc")
ufunc_betainc_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ibeta_double
ufunc_betainc_ptr[2*1+1] = <void*>(<char*>"betainc")
ufunc_betainc_data[0] = &ufunc_betainc_ptr[2*0]
ufunc_betainc_data[1] = &ufunc_betainc_ptr[2*1]
betainc = np.PyUFunc_FromFuncAndData(ufunc_betainc_loops, ufunc_betainc_data, ufunc_betainc_types, 2, 3, 1, 0, "betainc", ufunc_betainc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_betaincc_loops[2]
cdef void *ufunc_betaincc_ptr[4]
cdef void *ufunc_betaincc_data[2]
cdef char ufunc_betaincc_types[8]
cdef char *ufunc_betaincc_doc = (
    "betaincc(a, b, x, out=None)\n"
    "\n"
    "Complement of the regularized incomplete beta function.\n"
    "\n"
    "Computes the complement of the regularized incomplete beta function,\n"
    "defined as [1]_:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\bar{I}_x(a, b) = 1 - I_x(a, b)\n"
    "                    = 1 - \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)} \\int_0^x\n"
    "                              t^{a-1}(1-t)^{b-1}dt,\n"
    "\n"
    "for :math:`0 \\leq x \\leq 1`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "       Positive, real-valued parameters\n"
    "x : array_like\n"
    "    Real-valued such that :math:`0 \\leq x \\leq 1`,\n"
    "    the upper limit of integration\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the regularized incomplete beta function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "betainc : regularized incomplete beta function\n"
    "betaincinv : inverse of the regularized incomplete beta function\n"
    "betainccinv :\n"
    "    inverse of the complement of the regularized incomplete beta function\n"
    "beta : beta function\n"
    "scipy.stats.beta : beta distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    ".. versionadded:: 1.11.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       https://dlmf.nist.gov/8.17\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import betaincc, betainc\n"
    "\n"
    "The naive calculation ``1 - betainc(a, b, x)`` loses precision when\n"
    "the values of ``betainc(a, b, x)`` are close to 1:\n"
    "\n"
    ">>> 1 - betainc(0.5, 8, [0.9, 0.99, 0.999])\n"
    "array([2.0574632e-09, 0.0000000e+00, 0.0000000e+00])\n"
    "\n"
    "By using ``betaincc``, we get the correct values:\n"
    "\n"
    ">>> betaincc(0.5, 8, [0.9, 0.99, 0.999])\n"
    "array([2.05746321e-09, 1.97259354e-17, 1.96467954e-25])")
ufunc_betaincc_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc_betaincc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_betaincc_types[0] = <char>NPY_FLOAT
ufunc_betaincc_types[1] = <char>NPY_FLOAT
ufunc_betaincc_types[2] = <char>NPY_FLOAT
ufunc_betaincc_types[3] = <char>NPY_FLOAT
ufunc_betaincc_types[4] = <char>NPY_DOUBLE
ufunc_betaincc_types[5] = <char>NPY_DOUBLE
ufunc_betaincc_types[6] = <char>NPY_DOUBLE
ufunc_betaincc_types[7] = <char>NPY_DOUBLE
ufunc_betaincc_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ibetac_float
ufunc_betaincc_ptr[2*0+1] = <void*>(<char*>"betaincc")
ufunc_betaincc_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ibetac_double
ufunc_betaincc_ptr[2*1+1] = <void*>(<char*>"betaincc")
ufunc_betaincc_data[0] = &ufunc_betaincc_ptr[2*0]
ufunc_betaincc_data[1] = &ufunc_betaincc_ptr[2*1]
betaincc = np.PyUFunc_FromFuncAndData(ufunc_betaincc_loops, ufunc_betaincc_data, ufunc_betaincc_types, 2, 3, 1, 0, "betaincc", ufunc_betaincc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_betainccinv_loops[2]
cdef void *ufunc_betainccinv_ptr[4]
cdef void *ufunc_betainccinv_data[2]
cdef char ufunc_betainccinv_types[8]
cdef char *ufunc_betainccinv_doc = (
    "betainccinv(a, b, y, out=None)\n"
    "\n"
    "Inverse of the complemented regularized incomplete beta function.\n"
    "\n"
    "Computes :math:`x` such that:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    y = 1 - I_x(a, b) = 1 - \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)}\n"
    "    \\int_0^x t^{a-1}(1-t)^{b-1}dt,\n"
    "\n"
    "where :math:`I_x` is the normalized incomplete beta function `betainc`\n"
    "and :math:`\\Gamma` is the `gamma` function [1]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "    Positive, real-valued parameters\n"
    "y : array_like\n"
    "    Real-valued input\n"
    "out : ndarray, optional\n"
    "    Optional output array for function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the inverse of the regularized incomplete beta function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "betainc : regularized incomplete beta function\n"
    "betaincc : complement of the regularized incomplete beta function\n"
    "\n"
    "Notes\n"
    "-----\n"
    ".. versionadded:: 1.11.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       https://dlmf.nist.gov/8.17\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import betainccinv, betaincc\n"
    "\n"
    "This function is the inverse of `betaincc` for fixed\n"
    "values of :math:`a` and :math:`b`.\n"
    "\n"
    ">>> a, b = 1.2, 3.1\n"
    ">>> y = betaincc(a, b, 0.2)\n"
    ">>> betainccinv(a, b, y)\n"
    "0.2\n"
    "\n"
    ">>> a, b = 7, 2.5\n"
    ">>> x = betainccinv(a, b, 0.875)\n"
    ">>> betaincc(a, b, x)\n"
    "0.875")
ufunc_betainccinv_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc_betainccinv_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_betainccinv_types[0] = <char>NPY_FLOAT
ufunc_betainccinv_types[1] = <char>NPY_FLOAT
ufunc_betainccinv_types[2] = <char>NPY_FLOAT
ufunc_betainccinv_types[3] = <char>NPY_FLOAT
ufunc_betainccinv_types[4] = <char>NPY_DOUBLE
ufunc_betainccinv_types[5] = <char>NPY_DOUBLE
ufunc_betainccinv_types[6] = <char>NPY_DOUBLE
ufunc_betainccinv_types[7] = <char>NPY_DOUBLE
ufunc_betainccinv_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ibetac_inv_float
ufunc_betainccinv_ptr[2*0+1] = <void*>(<char*>"betainccinv")
ufunc_betainccinv_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ibetac_inv_double
ufunc_betainccinv_ptr[2*1+1] = <void*>(<char*>"betainccinv")
ufunc_betainccinv_data[0] = &ufunc_betainccinv_ptr[2*0]
ufunc_betainccinv_data[1] = &ufunc_betainccinv_ptr[2*1]
betainccinv = np.PyUFunc_FromFuncAndData(ufunc_betainccinv_loops, ufunc_betainccinv_data, ufunc_betainccinv_types, 2, 3, 1, 0, "betainccinv", ufunc_betainccinv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_betaincinv_loops[2]
cdef void *ufunc_betaincinv_ptr[4]
cdef void *ufunc_betaincinv_data[2]
cdef char ufunc_betaincinv_types[8]
cdef char *ufunc_betaincinv_doc = (
    "betaincinv(a, b, y, out=None)\n"
    "\n"
    "Inverse of the regularized incomplete beta function.\n"
    "\n"
    "Computes :math:`x` such that:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    y = I_x(a, b) = \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)}\n"
    "    \\int_0^x t^{a-1}(1-t)^{b-1}dt,\n"
    "\n"
    "where :math:`I_x` is the normalized incomplete beta function `betainc`\n"
    "and :math:`\\Gamma` is the `gamma` function [1]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "    Positive, real-valued parameters\n"
    "y : array_like\n"
    "    Real-valued input\n"
    "out : ndarray, optional\n"
    "    Optional output array for function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the inverse of the regularized incomplete beta function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "betainc : regularized incomplete beta function\n"
    "gamma : gamma function\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       https://dlmf.nist.gov/8.17\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "This function is the inverse of `betainc` for fixed\n"
    "values of :math:`a` and :math:`b`.\n"
    "\n"
    ">>> a, b = 1.2, 3.1\n"
    ">>> y = sc.betainc(a, b, 0.2)\n"
    ">>> sc.betaincinv(a, b, y)\n"
    "0.2\n"
    ">>>\n"
    ">>> a, b = 7.5, 0.4\n"
    ">>> x = sc.betaincinv(a, b, 0.5)\n"
    ">>> sc.betainc(a, b, x)\n"
    "0.5")
ufunc_betaincinv_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc_betaincinv_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_betaincinv_types[0] = <char>NPY_FLOAT
ufunc_betaincinv_types[1] = <char>NPY_FLOAT
ufunc_betaincinv_types[2] = <char>NPY_FLOAT
ufunc_betaincinv_types[3] = <char>NPY_FLOAT
ufunc_betaincinv_types[4] = <char>NPY_DOUBLE
ufunc_betaincinv_types[5] = <char>NPY_DOUBLE
ufunc_betaincinv_types[6] = <char>NPY_DOUBLE
ufunc_betaincinv_types[7] = <char>NPY_DOUBLE
ufunc_betaincinv_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ibeta_inv_float
ufunc_betaincinv_ptr[2*0+1] = <void*>(<char*>"betaincinv")
ufunc_betaincinv_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ibeta_inv_double
ufunc_betaincinv_ptr[2*1+1] = <void*>(<char*>"betaincinv")
ufunc_betaincinv_data[0] = &ufunc_betaincinv_ptr[2*0]
ufunc_betaincinv_data[1] = &ufunc_betaincinv_ptr[2*1]
betaincinv = np.PyUFunc_FromFuncAndData(ufunc_betaincinv_loops, ufunc_betaincinv_data, ufunc_betaincinv_types, 2, 3, 1, 0, "betaincinv", ufunc_betaincinv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_betaln_loops[2]
cdef void *ufunc_betaln_ptr[4]
cdef void *ufunc_betaln_data[2]
cdef char ufunc_betaln_types[6]
cdef char *ufunc_betaln_doc = (
    "betaln(a, b, out=None)\n"
    "\n"
    "Natural logarithm of absolute value of beta function.\n"
    "\n"
    "Computes ``ln(abs(beta(a, b)))``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "    Positive, real-valued parameters\n"
    "out : ndarray, optional\n"
    "    Optional output array for function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the betaln function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gamma : the gamma function\n"
    "betainc :  the regularized incomplete beta function\n"
    "beta : the beta function\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import betaln, beta\n"
    "\n"
    "Verify that, for moderate values of ``a`` and ``b``, ``betaln(a, b)``\n"
    "is the same as ``log(beta(a, b))``:\n"
    "\n"
    ">>> betaln(3, 4)\n"
    "-4.0943445622221\n"
    "\n"
    ">>> np.log(beta(3, 4))\n"
    "-4.0943445622221\n"
    "\n"
    "In the following ``beta(a, b)`` underflows to 0, so we can't compute\n"
    "the logarithm of the actual value.\n"
    "\n"
    ">>> a = 400\n"
    ">>> b = 900\n"
    ">>> beta(a, b)\n"
    "0.0\n"
    "\n"
    "We can compute the logarithm of ``beta(a, b)`` by using `betaln`:\n"
    "\n"
    ">>> betaln(a, b)\n"
    "-804.3069951764146")
ufunc_betaln_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_betaln_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_betaln_types[0] = <char>NPY_FLOAT
ufunc_betaln_types[1] = <char>NPY_FLOAT
ufunc_betaln_types[2] = <char>NPY_FLOAT
ufunc_betaln_types[3] = <char>NPY_DOUBLE
ufunc_betaln_types[4] = <char>NPY_DOUBLE
ufunc_betaln_types[5] = <char>NPY_DOUBLE
ufunc_betaln_ptr[2*0] = <void*>_func_lbeta
ufunc_betaln_ptr[2*0+1] = <void*>(<char*>"betaln")
ufunc_betaln_ptr[2*1] = <void*>_func_lbeta
ufunc_betaln_ptr[2*1+1] = <void*>(<char*>"betaln")
ufunc_betaln_data[0] = &ufunc_betaln_ptr[2*0]
ufunc_betaln_data[1] = &ufunc_betaln_ptr[2*1]
betaln = np.PyUFunc_FromFuncAndData(ufunc_betaln_loops, ufunc_betaln_data, ufunc_betaln_types, 2, 2, 1, 0, "betaln", ufunc_betaln_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_binom_loops[2]
cdef void *ufunc_binom_ptr[4]
cdef void *ufunc_binom_data[2]
cdef char ufunc_binom_types[6]
cdef char *ufunc_binom_doc = (
    "binom(x, y, out=None)\n"
    "\n"
    "Binomial coefficient considered as a function of two real variables.\n"
    "\n"
    "For real arguments, the binomial coefficient is defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\binom{x}{y} = \\frac{\\Gamma(x + 1)}{\\Gamma(y + 1)\\Gamma(x - y + 1)} =\n"
    "        \\frac{1}{(x + 1)\\mathrm{B}(x - y + 1, y + 1)}\n"
    "\n"
    "Where :math:`\\Gamma` is the Gamma function (`gamma`) and :math:`\\mathrm{B}`\n"
    "is the Beta function (`beta`) [1]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x, y: array_like\n"
    "   Real arguments to :math:`\\binom{x}{y}`.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of binomial coefficient.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "comb : The number of combinations of N things taken k at a time.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The Gamma function has poles at non-positive integers and tends to either\n"
    "positive or negative infinity depending on the direction on the real line\n"
    "from which a pole is approached. When considered as a function of two real\n"
    "variables, :math:`\\binom{x}{y}` is thus undefined when `x` is a negative\n"
    "integer.  `binom` returns ``nan`` when ``x`` is a negative integer. This\n"
    "is the case even when ``x`` is a negative integer and ``y`` an integer,\n"
    "contrary to the usual convention for defining :math:`\\binom{n}{k}` when it\n"
    "is considered as a function of two integer variables.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] https://en.wikipedia.org/wiki/Binomial_coefficient\n"
    "\n"
    "Examples\n"
    "--------\n"
    "The following examples illustrate the ways in which `binom` differs from\n"
    "the function `comb`.\n"
    "\n"
    ">>> from scipy.special import binom, comb\n"
    "\n"
    "When ``exact=False`` and ``x`` and ``y`` are both positive, `comb` calls\n"
    "`binom` internally.\n"
    "\n"
    ">>> x, y = 3, 2\n"
    ">>> (binom(x, y), comb(x, y), comb(x, y, exact=True))\n"
    "(3.0, 3.0, 3)\n"
    "\n"
    "For larger values, `comb` with ``exact=True`` no longer agrees\n"
    "with `binom`.\n"
    "\n"
    ">>> x, y = 43, 23\n"
    ">>> (binom(x, y), comb(x, y), comb(x, y, exact=True))\n"
    "(960566918219.9999, 960566918219.9999, 960566918220)\n"
    "\n"
    "`binom` returns ``nan`` when ``x`` is a negative integer, but is otherwise\n"
    "defined for negative arguments. `comb` returns 0 whenever one of ``x`` or\n"
    "``y`` is negative or ``x`` is less than ``y``.\n"
    "\n"
    ">>> x, y = -3, 2\n"
    ">>> (binom(x, y), comb(x, y), comb(x, y, exact=True))\n"
    "(nan, 0.0, 0)\n"
    "\n"
    ">>> x, y = -3.1, 2.2\n"
    ">>> (binom(x, y), comb(x, y), comb(x, y, exact=True))\n"
    "(18.714147876804432, 0.0, 0)\n"
    "\n"
    ">>> x, y = 2.2, 3.1\n"
    ">>> (binom(x, y), comb(x, y), comb(x, y, exact=True))\n"
    "(0.037399983365134115, 0.0, 0)")
ufunc_binom_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_binom_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_binom_types[0] = <char>NPY_FLOAT
ufunc_binom_types[1] = <char>NPY_FLOAT
ufunc_binom_types[2] = <char>NPY_FLOAT
ufunc_binom_types[3] = <char>NPY_DOUBLE
ufunc_binom_types[4] = <char>NPY_DOUBLE
ufunc_binom_types[5] = <char>NPY_DOUBLE
ufunc_binom_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_binom
ufunc_binom_ptr[2*0+1] = <void*>(<char*>"binom")
ufunc_binom_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_binom
ufunc_binom_ptr[2*1+1] = <void*>(<char*>"binom")
ufunc_binom_data[0] = &ufunc_binom_ptr[2*0]
ufunc_binom_data[1] = &ufunc_binom_ptr[2*1]
binom = np.PyUFunc_FromFuncAndData(ufunc_binom_loops, ufunc_binom_data, ufunc_binom_types, 2, 2, 1, 0, "binom", ufunc_binom_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_boxcox_loops[2]
cdef void *ufunc_boxcox_ptr[4]
cdef void *ufunc_boxcox_data[2]
cdef char ufunc_boxcox_types[6]
cdef char *ufunc_boxcox_doc = (
    "boxcox(x, lmbda, out=None)\n"
    "\n"
    "Compute the Box-Cox transformation.\n"
    "\n"
    "The Box-Cox transformation is::\n"
    "\n"
    "    y = (x**lmbda - 1) / lmbda  if lmbda != 0\n"
    "        log(x)                  if lmbda == 0\n"
    "\n"
    "Returns `nan` if ``x < 0``.\n"
    "Returns `-inf` if ``x == 0`` and ``lmbda < 0``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Data to be transformed.\n"
    "lmbda : array_like\n"
    "    Power parameter of the Box-Cox transform.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Transformed data.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.14.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import boxcox\n"
    ">>> boxcox([1, 4, 10], 2.5)\n"
    "array([   0.        ,   12.4       ,  126.09110641])\n"
    ">>> boxcox(2, [0, 1, 2])\n"
    "array([ 0.69314718,  1.        ,  1.5       ])")
ufunc_boxcox_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_boxcox_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_boxcox_types[0] = <char>NPY_FLOAT
ufunc_boxcox_types[1] = <char>NPY_FLOAT
ufunc_boxcox_types[2] = <char>NPY_FLOAT
ufunc_boxcox_types[3] = <char>NPY_DOUBLE
ufunc_boxcox_types[4] = <char>NPY_DOUBLE
ufunc_boxcox_types[5] = <char>NPY_DOUBLE
ufunc_boxcox_ptr[2*0] = <void*>_func_boxcox
ufunc_boxcox_ptr[2*0+1] = <void*>(<char*>"boxcox")
ufunc_boxcox_ptr[2*1] = <void*>_func_boxcox
ufunc_boxcox_ptr[2*1+1] = <void*>(<char*>"boxcox")
ufunc_boxcox_data[0] = &ufunc_boxcox_ptr[2*0]
ufunc_boxcox_data[1] = &ufunc_boxcox_ptr[2*1]
boxcox = np.PyUFunc_FromFuncAndData(ufunc_boxcox_loops, ufunc_boxcox_data, ufunc_boxcox_types, 2, 2, 1, 0, "boxcox", ufunc_boxcox_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_boxcox1p_loops[2]
cdef void *ufunc_boxcox1p_ptr[4]
cdef void *ufunc_boxcox1p_data[2]
cdef char ufunc_boxcox1p_types[6]
cdef char *ufunc_boxcox1p_doc = (
    "boxcox1p(x, lmbda, out=None)\n"
    "\n"
    "Compute the Box-Cox transformation of 1 + `x`.\n"
    "\n"
    "The Box-Cox transformation computed by `boxcox1p` is::\n"
    "\n"
    "    y = ((1+x)**lmbda - 1) / lmbda  if lmbda != 0\n"
    "        log(1+x)                    if lmbda == 0\n"
    "\n"
    "Returns `nan` if ``x < -1``.\n"
    "Returns `-inf` if ``x == -1`` and ``lmbda < 0``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Data to be transformed.\n"
    "lmbda : array_like\n"
    "    Power parameter of the Box-Cox transform.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Transformed data.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.14.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import boxcox1p\n"
    ">>> boxcox1p(1e-4, [0, 0.5, 1])\n"
    "array([  9.99950003e-05,   9.99975001e-05,   1.00000000e-04])\n"
    ">>> boxcox1p([0.01, 0.1], 0.25)\n"
    "array([ 0.00996272,  0.09645476])")
ufunc_boxcox1p_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_boxcox1p_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_boxcox1p_types[0] = <char>NPY_FLOAT
ufunc_boxcox1p_types[1] = <char>NPY_FLOAT
ufunc_boxcox1p_types[2] = <char>NPY_FLOAT
ufunc_boxcox1p_types[3] = <char>NPY_DOUBLE
ufunc_boxcox1p_types[4] = <char>NPY_DOUBLE
ufunc_boxcox1p_types[5] = <char>NPY_DOUBLE
ufunc_boxcox1p_ptr[2*0] = <void*>_func_boxcox1p
ufunc_boxcox1p_ptr[2*0+1] = <void*>(<char*>"boxcox1p")
ufunc_boxcox1p_ptr[2*1] = <void*>_func_boxcox1p
ufunc_boxcox1p_ptr[2*1+1] = <void*>(<char*>"boxcox1p")
ufunc_boxcox1p_data[0] = &ufunc_boxcox1p_ptr[2*0]
ufunc_boxcox1p_data[1] = &ufunc_boxcox1p_ptr[2*1]
boxcox1p = np.PyUFunc_FromFuncAndData(ufunc_boxcox1p_loops, ufunc_boxcox1p_data, ufunc_boxcox1p_types, 2, 2, 1, 0, "boxcox1p", ufunc_boxcox1p_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_btdtr_loops[2]
cdef void *ufunc_btdtr_ptr[4]
cdef void *ufunc_btdtr_data[2]
cdef char ufunc_btdtr_types[8]
cdef char *ufunc_btdtr_doc = (
    "btdtr(a, b, x, out=None)\n"
    "\n"
    "Cumulative distribution function of the beta distribution.\n"
    "\n"
    "Returns the integral from zero to `x` of the beta probability density\n"
    "function,\n"
    "\n"
    ".. math::\n"
    "    I = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n"
    "\n"
    "where :math:`\\Gamma` is the gamma function.\n"
    "\n"
    ".. deprecated:: 1.12.0\n"
    "    This function is deprecated and will be removed from SciPy 1.14.0.\n"
    "    Use `scipy.special.betainc` instead.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    Shape parameter (a > 0).\n"
    "b : array_like\n"
    "    Shape parameter (b > 0).\n"
    "x : array_like\n"
    "    Upper limit of integration, in [0, 1].\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "I : scalar or ndarray\n"
    "    Cumulative distribution function of the beta distribution with\n"
    "    parameters `a` and `b` at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "betainc\n"
    "\n"
    "Notes\n"
    "-----\n"
    "This function is identical to the incomplete beta integral function\n"
    "`betainc`.\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `btdtr`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/")
ufunc_btdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_btdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_btdtr_types[0] = <char>NPY_FLOAT
ufunc_btdtr_types[1] = <char>NPY_FLOAT
ufunc_btdtr_types[2] = <char>NPY_FLOAT
ufunc_btdtr_types[3] = <char>NPY_FLOAT
ufunc_btdtr_types[4] = <char>NPY_DOUBLE
ufunc_btdtr_types[5] = <char>NPY_DOUBLE
ufunc_btdtr_types[6] = <char>NPY_DOUBLE
ufunc_btdtr_types[7] = <char>NPY_DOUBLE
ufunc_btdtr_ptr[2*0] = <void*>_func_btdtr
ufunc_btdtr_ptr[2*0+1] = <void*>(<char*>"btdtr")
ufunc_btdtr_ptr[2*1] = <void*>_func_btdtr
ufunc_btdtr_ptr[2*1+1] = <void*>(<char*>"btdtr")
ufunc_btdtr_data[0] = &ufunc_btdtr_ptr[2*0]
ufunc_btdtr_data[1] = &ufunc_btdtr_ptr[2*1]
btdtr = np.PyUFunc_FromFuncAndData(ufunc_btdtr_loops, ufunc_btdtr_data, ufunc_btdtr_types, 2, 3, 1, 0, "btdtr", ufunc_btdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_btdtri_loops[2]
cdef void *ufunc_btdtri_ptr[4]
cdef void *ufunc_btdtri_data[2]
cdef char ufunc_btdtri_types[8]
cdef char *ufunc_btdtri_doc = (
    "btdtri(a, b, p, out=None)\n"
    "\n"
    "The `p`-th quantile of the beta distribution.\n"
    "\n"
    "This function is the inverse of the beta cumulative distribution function,\n"
    "`btdtr`, returning the value of `x` for which `btdtr(a, b, x) = p`, or\n"
    "\n"
    ".. math::\n"
    "    p = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n"
    "\n"
    ".. deprecated:: 1.12.0\n"
    "    This function is deprecated and will be removed from SciPy 1.14.0.\n"
    "    Use `scipy.special.betaincinv` instead.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    Shape parameter (`a` > 0).\n"
    "b : array_like\n"
    "    Shape parameter (`b` > 0).\n"
    "p : array_like\n"
    "    Cumulative probability, in [0, 1].\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    The quantile corresponding to `p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "betaincinv\n"
    "btdtr\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The value of `x` is found by interval halving or Newton iterations.\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `incbi`, which solves the equivalent\n"
    "problem of finding the inverse of the incomplete beta integral.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/")
ufunc_btdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_btdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_btdtri_types[0] = <char>NPY_FLOAT
ufunc_btdtri_types[1] = <char>NPY_FLOAT
ufunc_btdtri_types[2] = <char>NPY_FLOAT
ufunc_btdtri_types[3] = <char>NPY_FLOAT
ufunc_btdtri_types[4] = <char>NPY_DOUBLE
ufunc_btdtri_types[5] = <char>NPY_DOUBLE
ufunc_btdtri_types[6] = <char>NPY_DOUBLE
ufunc_btdtri_types[7] = <char>NPY_DOUBLE
ufunc_btdtri_ptr[2*0] = <void*>_func_incbi
ufunc_btdtri_ptr[2*0+1] = <void*>(<char*>"btdtri")
ufunc_btdtri_ptr[2*1] = <void*>_func_incbi
ufunc_btdtri_ptr[2*1+1] = <void*>(<char*>"btdtri")
ufunc_btdtri_data[0] = &ufunc_btdtri_ptr[2*0]
ufunc_btdtri_data[1] = &ufunc_btdtri_ptr[2*1]
btdtri = np.PyUFunc_FromFuncAndData(ufunc_btdtri_loops, ufunc_btdtri_data, ufunc_btdtri_types, 2, 3, 1, 0, "btdtri", ufunc_btdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_btdtria_loops[2]
cdef void *ufunc_btdtria_ptr[4]
cdef void *ufunc_btdtria_data[2]
cdef char ufunc_btdtria_types[8]
cdef char *ufunc_btdtria_doc = (
    "btdtria(p, b, x, out=None)\n"
    "\n"
    "Inverse of `btdtr` with respect to `a`.\n"
    "\n"
    "This is the inverse of the beta cumulative distribution function, `btdtr`,\n"
    "considered as a function of `a`, returning the value of `a` for which\n"
    "`btdtr(a, b, x) = p`, or\n"
    "\n"
    ".. math::\n"
    "    p = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Cumulative probability, in [0, 1].\n"
    "b : array_like\n"
    "    Shape parameter (`b` > 0).\n"
    "x : array_like\n"
    "    The quantile, in [0, 1].\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "a : scalar or ndarray\n"
    "    The value of the shape parameter `a` such that `btdtr(a, b, x) = p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "btdtr : Cumulative distribution function of the beta distribution.\n"
    "btdtri : Inverse with respect to `x`.\n"
    "btdtrib : Inverse with respect to `b`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfbet`.\n"
    "\n"
    "The cumulative distribution function `p` is computed using a routine by\n"
    "DiDinato and Morris [2]_. Computation of `a` involves a search for a value\n"
    "that produces the desired value of `p`. The search relies on the\n"
    "monotonicity of `p` with `a`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] DiDinato, A. R. and Morris, A. H.,\n"
    "       Algorithm 708: Significant Digit Computation of the Incomplete Beta\n"
    "       Function Ratios. ACM Trans. Math. Softw. 18 (1993), 360-373.")
ufunc_btdtria_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_btdtria_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_btdtria_types[0] = <char>NPY_FLOAT
ufunc_btdtria_types[1] = <char>NPY_FLOAT
ufunc_btdtria_types[2] = <char>NPY_FLOAT
ufunc_btdtria_types[3] = <char>NPY_FLOAT
ufunc_btdtria_types[4] = <char>NPY_DOUBLE
ufunc_btdtria_types[5] = <char>NPY_DOUBLE
ufunc_btdtria_types[6] = <char>NPY_DOUBLE
ufunc_btdtria_types[7] = <char>NPY_DOUBLE
ufunc_btdtria_ptr[2*0] = <void*>_func_btdtria
ufunc_btdtria_ptr[2*0+1] = <void*>(<char*>"btdtria")
ufunc_btdtria_ptr[2*1] = <void*>_func_btdtria
ufunc_btdtria_ptr[2*1+1] = <void*>(<char*>"btdtria")
ufunc_btdtria_data[0] = &ufunc_btdtria_ptr[2*0]
ufunc_btdtria_data[1] = &ufunc_btdtria_ptr[2*1]
btdtria = np.PyUFunc_FromFuncAndData(ufunc_btdtria_loops, ufunc_btdtria_data, ufunc_btdtria_types, 2, 3, 1, 0, "btdtria", ufunc_btdtria_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_btdtrib_loops[2]
cdef void *ufunc_btdtrib_ptr[4]
cdef void *ufunc_btdtrib_data[2]
cdef char ufunc_btdtrib_types[8]
cdef char *ufunc_btdtrib_doc = (
    "btdtria(a, p, x, out=None)\n"
    "\n"
    "Inverse of `btdtr` with respect to `b`.\n"
    "\n"
    "This is the inverse of the beta cumulative distribution function, `btdtr`,\n"
    "considered as a function of `b`, returning the value of `b` for which\n"
    "`btdtr(a, b, x) = p`, or\n"
    "\n"
    ".. math::\n"
    "    p = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    Shape parameter (`a` > 0).\n"
    "p : array_like\n"
    "    Cumulative probability, in [0, 1].\n"
    "x : array_like\n"
    "    The quantile, in [0, 1].\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "b : scalar or ndarray\n"
    "    The value of the shape parameter `b` such that `btdtr(a, b, x) = p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "btdtr : Cumulative distribution function of the beta distribution.\n"
    "btdtri : Inverse with respect to `x`.\n"
    "btdtria : Inverse with respect to `a`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfbet`.\n"
    "\n"
    "The cumulative distribution function `p` is computed using a routine by\n"
    "DiDinato and Morris [2]_. Computation of `b` involves a search for a value\n"
    "that produces the desired value of `p`. The search relies on the\n"
    "monotonicity of `p` with `b`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] DiDinato, A. R. and Morris, A. H.,\n"
    "       Algorithm 708: Significant Digit Computation of the Incomplete Beta\n"
    "       Function Ratios. ACM Trans. Math. Softw. 18 (1993), 360-373.")
ufunc_btdtrib_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_btdtrib_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_btdtrib_types[0] = <char>NPY_FLOAT
ufunc_btdtrib_types[1] = <char>NPY_FLOAT
ufunc_btdtrib_types[2] = <char>NPY_FLOAT
ufunc_btdtrib_types[3] = <char>NPY_FLOAT
ufunc_btdtrib_types[4] = <char>NPY_DOUBLE
ufunc_btdtrib_types[5] = <char>NPY_DOUBLE
ufunc_btdtrib_types[6] = <char>NPY_DOUBLE
ufunc_btdtrib_types[7] = <char>NPY_DOUBLE
ufunc_btdtrib_ptr[2*0] = <void*>_func_btdtrib
ufunc_btdtrib_ptr[2*0+1] = <void*>(<char*>"btdtrib")
ufunc_btdtrib_ptr[2*1] = <void*>_func_btdtrib
ufunc_btdtrib_ptr[2*1+1] = <void*>(<char*>"btdtrib")
ufunc_btdtrib_data[0] = &ufunc_btdtrib_ptr[2*0]
ufunc_btdtrib_data[1] = &ufunc_btdtrib_ptr[2*1]
btdtrib = np.PyUFunc_FromFuncAndData(ufunc_btdtrib_loops, ufunc_btdtrib_data, ufunc_btdtrib_types, 2, 3, 1, 0, "btdtrib", ufunc_btdtrib_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_cbrt_loops[2]
cdef void *ufunc_cbrt_ptr[4]
cdef void *ufunc_cbrt_data[2]
cdef char ufunc_cbrt_types[4]
cdef char *ufunc_cbrt_doc = (
    "cbrt(x, out=None)\n"
    "\n"
    "Element-wise cube root of `x`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    `x` must contain real numbers.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The cube root of each value in `x`.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import cbrt\n"
    "\n"
    ">>> cbrt(8)\n"
    "2.0\n"
    ">>> cbrt([-8, -3, 0.125, 1.331])\n"
    "array([-2.        , -1.44224957,  0.5       ,  1.1       ])")
ufunc_cbrt_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_cbrt_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_cbrt_types[0] = <char>NPY_FLOAT
ufunc_cbrt_types[1] = <char>NPY_FLOAT
ufunc_cbrt_types[2] = <char>NPY_DOUBLE
ufunc_cbrt_types[3] = <char>NPY_DOUBLE
ufunc_cbrt_ptr[2*0] = <void*>_func_cbrt
ufunc_cbrt_ptr[2*0+1] = <void*>(<char*>"cbrt")
ufunc_cbrt_ptr[2*1] = <void*>_func_cbrt
ufunc_cbrt_ptr[2*1+1] = <void*>(<char*>"cbrt")
ufunc_cbrt_data[0] = &ufunc_cbrt_ptr[2*0]
ufunc_cbrt_data[1] = &ufunc_cbrt_ptr[2*1]
cbrt = np.PyUFunc_FromFuncAndData(ufunc_cbrt_loops, ufunc_cbrt_data, ufunc_cbrt_types, 2, 1, 1, 0, "cbrt", ufunc_cbrt_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chdtr_loops[2]
cdef void *ufunc_chdtr_ptr[4]
cdef void *ufunc_chdtr_data[2]
cdef char ufunc_chdtr_types[6]
cdef char *ufunc_chdtr_doc = (
    "chdtr(v, x, out=None)\n"
    "\n"
    "Chi square cumulative distribution function.\n"
    "\n"
    "Returns the area under the left tail (from 0 to `x`) of the Chi\n"
    "square probability density function with `v` degrees of freedom:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\frac{1}{2^{v/2} \\Gamma(v/2)} \\int_0^x t^{v/2 - 1} e^{-t/2} dt\n"
    "\n"
    "Here :math:`\\Gamma` is the Gamma function; see `gamma`. This\n"
    "integral can be expressed in terms of the regularized lower\n"
    "incomplete gamma function `gammainc` as\n"
    "``gammainc(v / 2, x / 2)``. [1]_\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Degrees of freedom.\n"
    "x : array_like\n"
    "    Upper bound of the integral.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the cumulative distribution function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chdtrc, chdtri, chdtriv, gammainc\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Chi-Square distribution,\n"
    "    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It can be expressed in terms of the regularized lower incomplete\n"
    "gamma function.\n"
    "\n"
    ">>> v = 1\n"
    ">>> x = np.arange(4)\n"
    ">>> sc.chdtr(v, x)\n"
    "array([0.        , 0.68268949, 0.84270079, 0.91673548])\n"
    ">>> sc.gammainc(v / 2, x / 2)\n"
    "array([0.        , 0.68268949, 0.84270079, 0.91673548])")
ufunc_chdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_chdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_chdtr_types[0] = <char>NPY_FLOAT
ufunc_chdtr_types[1] = <char>NPY_FLOAT
ufunc_chdtr_types[2] = <char>NPY_FLOAT
ufunc_chdtr_types[3] = <char>NPY_DOUBLE
ufunc_chdtr_types[4] = <char>NPY_DOUBLE
ufunc_chdtr_types[5] = <char>NPY_DOUBLE
ufunc_chdtr_ptr[2*0] = <void*>_func_chdtr
ufunc_chdtr_ptr[2*0+1] = <void*>(<char*>"chdtr")
ufunc_chdtr_ptr[2*1] = <void*>_func_chdtr
ufunc_chdtr_ptr[2*1+1] = <void*>(<char*>"chdtr")
ufunc_chdtr_data[0] = &ufunc_chdtr_ptr[2*0]
ufunc_chdtr_data[1] = &ufunc_chdtr_ptr[2*1]
chdtr = np.PyUFunc_FromFuncAndData(ufunc_chdtr_loops, ufunc_chdtr_data, ufunc_chdtr_types, 2, 2, 1, 0, "chdtr", ufunc_chdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chdtrc_loops[2]
cdef void *ufunc_chdtrc_ptr[4]
cdef void *ufunc_chdtrc_data[2]
cdef char ufunc_chdtrc_types[6]
cdef char *ufunc_chdtrc_doc = (
    "chdtrc(v, x, out=None)\n"
    "\n"
    "Chi square survival function.\n"
    "\n"
    "Returns the area under the right hand tail (from `x` to infinity)\n"
    "of the Chi square probability density function with `v` degrees of\n"
    "freedom:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\frac{1}{2^{v/2} \\Gamma(v/2)} \\int_x^\\infty t^{v/2 - 1} e^{-t/2} dt\n"
    "\n"
    "Here :math:`\\Gamma` is the Gamma function; see `gamma`. This\n"
    "integral can be expressed in terms of the regularized upper\n"
    "incomplete gamma function `gammaincc` as\n"
    "``gammaincc(v / 2, x / 2)``. [1]_\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Degrees of freedom.\n"
    "x : array_like\n"
    "    Lower bound of the integral.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the survival function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chdtr, chdtri, chdtriv, gammaincc\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Chi-Square distribution,\n"
    "    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It can be expressed in terms of the regularized upper incomplete\n"
    "gamma function.\n"
    "\n"
    ">>> v = 1\n"
    ">>> x = np.arange(4)\n"
    ">>> sc.chdtrc(v, x)\n"
    "array([1.        , 0.31731051, 0.15729921, 0.08326452])\n"
    ">>> sc.gammaincc(v / 2, x / 2)\n"
    "array([1.        , 0.31731051, 0.15729921, 0.08326452])")
ufunc_chdtrc_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_chdtrc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_chdtrc_types[0] = <char>NPY_FLOAT
ufunc_chdtrc_types[1] = <char>NPY_FLOAT
ufunc_chdtrc_types[2] = <char>NPY_FLOAT
ufunc_chdtrc_types[3] = <char>NPY_DOUBLE
ufunc_chdtrc_types[4] = <char>NPY_DOUBLE
ufunc_chdtrc_types[5] = <char>NPY_DOUBLE
ufunc_chdtrc_ptr[2*0] = <void*>_func_chdtrc
ufunc_chdtrc_ptr[2*0+1] = <void*>(<char*>"chdtrc")
ufunc_chdtrc_ptr[2*1] = <void*>_func_chdtrc
ufunc_chdtrc_ptr[2*1+1] = <void*>(<char*>"chdtrc")
ufunc_chdtrc_data[0] = &ufunc_chdtrc_ptr[2*0]
ufunc_chdtrc_data[1] = &ufunc_chdtrc_ptr[2*1]
chdtrc = np.PyUFunc_FromFuncAndData(ufunc_chdtrc_loops, ufunc_chdtrc_data, ufunc_chdtrc_types, 2, 2, 1, 0, "chdtrc", ufunc_chdtrc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chdtri_loops[2]
cdef void *ufunc_chdtri_ptr[4]
cdef void *ufunc_chdtri_data[2]
cdef char ufunc_chdtri_types[6]
cdef char *ufunc_chdtri_doc = (
    "chdtri(v, p, out=None)\n"
    "\n"
    "Inverse to `chdtrc` with respect to `x`.\n"
    "\n"
    "Returns `x` such that ``chdtrc(v, x) == p``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Degrees of freedom.\n"
    "p : array_like\n"
    "    Probability.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    Value so that the probability a Chi square random variable\n"
    "    with `v` degrees of freedom is greater than `x` equals `p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chdtrc, chdtr, chdtriv\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Chi-Square distribution,\n"
    "    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It inverts `chdtrc`.\n"
    "\n"
    ">>> v, p = 1, 0.3\n"
    ">>> sc.chdtrc(v, sc.chdtri(v, p))\n"
    "0.3\n"
    ">>> x = 1\n"
    ">>> sc.chdtri(v, sc.chdtrc(v, x))\n"
    "1.0")
ufunc_chdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_chdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_chdtri_types[0] = <char>NPY_FLOAT
ufunc_chdtri_types[1] = <char>NPY_FLOAT
ufunc_chdtri_types[2] = <char>NPY_FLOAT
ufunc_chdtri_types[3] = <char>NPY_DOUBLE
ufunc_chdtri_types[4] = <char>NPY_DOUBLE
ufunc_chdtri_types[5] = <char>NPY_DOUBLE
ufunc_chdtri_ptr[2*0] = <void*>_func_chdtri
ufunc_chdtri_ptr[2*0+1] = <void*>(<char*>"chdtri")
ufunc_chdtri_ptr[2*1] = <void*>_func_chdtri
ufunc_chdtri_ptr[2*1+1] = <void*>(<char*>"chdtri")
ufunc_chdtri_data[0] = &ufunc_chdtri_ptr[2*0]
ufunc_chdtri_data[1] = &ufunc_chdtri_ptr[2*1]
chdtri = np.PyUFunc_FromFuncAndData(ufunc_chdtri_loops, ufunc_chdtri_data, ufunc_chdtri_types, 2, 2, 1, 0, "chdtri", ufunc_chdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chdtriv_loops[2]
cdef void *ufunc_chdtriv_ptr[4]
cdef void *ufunc_chdtriv_data[2]
cdef char ufunc_chdtriv_types[6]
cdef char *ufunc_chdtriv_doc = (
    "chdtriv(p, x, out=None)\n"
    "\n"
    "Inverse to `chdtr` with respect to `v`.\n"
    "\n"
    "Returns `v` such that ``chdtr(v, x) == p``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Probability that the Chi square random variable is less than\n"
    "    or equal to `x`.\n"
    "x : array_like\n"
    "    Nonnegative input.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Degrees of freedom.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chdtr, chdtrc, chdtri\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Chi-Square distribution,\n"
    "    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It inverts `chdtr`.\n"
    "\n"
    ">>> p, x = 0.5, 1\n"
    ">>> sc.chdtr(sc.chdtriv(p, x), x)\n"
    "0.5000000000202172\n"
    ">>> v = 1\n"
    ">>> sc.chdtriv(sc.chdtr(v, x), v)\n"
    "1.0000000000000013")
ufunc_chdtriv_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_chdtriv_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_chdtriv_types[0] = <char>NPY_FLOAT
ufunc_chdtriv_types[1] = <char>NPY_FLOAT
ufunc_chdtriv_types[2] = <char>NPY_FLOAT
ufunc_chdtriv_types[3] = <char>NPY_DOUBLE
ufunc_chdtriv_types[4] = <char>NPY_DOUBLE
ufunc_chdtriv_types[5] = <char>NPY_DOUBLE
ufunc_chdtriv_ptr[2*0] = <void*>_func_chdtriv
ufunc_chdtriv_ptr[2*0+1] = <void*>(<char*>"chdtriv")
ufunc_chdtriv_ptr[2*1] = <void*>_func_chdtriv
ufunc_chdtriv_ptr[2*1+1] = <void*>(<char*>"chdtriv")
ufunc_chdtriv_data[0] = &ufunc_chdtriv_ptr[2*0]
ufunc_chdtriv_data[1] = &ufunc_chdtriv_ptr[2*1]
chdtriv = np.PyUFunc_FromFuncAndData(ufunc_chdtriv_loops, ufunc_chdtriv_data, ufunc_chdtriv_types, 2, 2, 1, 0, "chdtriv", ufunc_chdtriv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chndtr_loops[2]
cdef void *ufunc_chndtr_ptr[4]
cdef void *ufunc_chndtr_data[2]
cdef char ufunc_chndtr_types[8]
cdef char *ufunc_chndtr_doc = (
    "chndtr(x, df, nc, out=None)\n"
    "\n"
    "Non-central chi square cumulative distribution function\n"
    "\n"
    "The cumulative distribution function is given by:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    P(\\chi^{\\prime 2} \\vert \\nu, \\lambda) =\\sum_{j=0}^{\\infty}\n"
    "    e^{-\\lambda /2}\n"
    "    \\frac{(\\lambda /2)^j}{j!} P(\\chi^{\\prime 2} \\vert \\nu + 2j),\n"
    "\n"
    "where :math:`\\nu > 0` is the degrees of freedom (``df``) and\n"
    ":math:`\\lambda \\geq 0` is the non-centrality parameter (``nc``).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Upper bound of the integral; must satisfy ``x >= 0``\n"
    "df : array_like\n"
    "    Degrees of freedom; must satisfy ``df > 0``\n"
    "nc : array_like\n"
    "    Non-centrality parameter; must satisfy ``nc >= 0``\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    Value of the non-central chi square cumulative distribution function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chndtrix, chndtridf, chndtrinc")
ufunc_chndtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_chndtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_chndtr_types[0] = <char>NPY_FLOAT
ufunc_chndtr_types[1] = <char>NPY_FLOAT
ufunc_chndtr_types[2] = <char>NPY_FLOAT
ufunc_chndtr_types[3] = <char>NPY_FLOAT
ufunc_chndtr_types[4] = <char>NPY_DOUBLE
ufunc_chndtr_types[5] = <char>NPY_DOUBLE
ufunc_chndtr_types[6] = <char>NPY_DOUBLE
ufunc_chndtr_types[7] = <char>NPY_DOUBLE
ufunc_chndtr_ptr[2*0] = <void*>_func_chndtr
ufunc_chndtr_ptr[2*0+1] = <void*>(<char*>"chndtr")
ufunc_chndtr_ptr[2*1] = <void*>_func_chndtr
ufunc_chndtr_ptr[2*1+1] = <void*>(<char*>"chndtr")
ufunc_chndtr_data[0] = &ufunc_chndtr_ptr[2*0]
ufunc_chndtr_data[1] = &ufunc_chndtr_ptr[2*1]
chndtr = np.PyUFunc_FromFuncAndData(ufunc_chndtr_loops, ufunc_chndtr_data, ufunc_chndtr_types, 2, 3, 1, 0, "chndtr", ufunc_chndtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chndtridf_loops[2]
cdef void *ufunc_chndtridf_ptr[4]
cdef void *ufunc_chndtridf_data[2]
cdef char ufunc_chndtridf_types[8]
cdef char *ufunc_chndtridf_doc = (
    "chndtridf(x, p, nc, out=None)\n"
    "\n"
    "Inverse to `chndtr` vs `df`\n"
    "\n"
    "Calculated using a search to find a value for `df` that produces the\n"
    "desired value of `p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Upper bound of the integral; must satisfy ``x >= 0``\n"
    "p : array_like\n"
    "    Probability; must satisfy ``0 <= p < 1``\n"
    "nc : array_like\n"
    "    Non-centrality parameter; must satisfy ``nc >= 0``\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "df : scalar or ndarray\n"
    "    Degrees of freedom\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chndtr, chndtrix, chndtrinc")
ufunc_chndtridf_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_chndtridf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_chndtridf_types[0] = <char>NPY_FLOAT
ufunc_chndtridf_types[1] = <char>NPY_FLOAT
ufunc_chndtridf_types[2] = <char>NPY_FLOAT
ufunc_chndtridf_types[3] = <char>NPY_FLOAT
ufunc_chndtridf_types[4] = <char>NPY_DOUBLE
ufunc_chndtridf_types[5] = <char>NPY_DOUBLE
ufunc_chndtridf_types[6] = <char>NPY_DOUBLE
ufunc_chndtridf_types[7] = <char>NPY_DOUBLE
ufunc_chndtridf_ptr[2*0] = <void*>_func_chndtridf
ufunc_chndtridf_ptr[2*0+1] = <void*>(<char*>"chndtridf")
ufunc_chndtridf_ptr[2*1] = <void*>_func_chndtridf
ufunc_chndtridf_ptr[2*1+1] = <void*>(<char*>"chndtridf")
ufunc_chndtridf_data[0] = &ufunc_chndtridf_ptr[2*0]
ufunc_chndtridf_data[1] = &ufunc_chndtridf_ptr[2*1]
chndtridf = np.PyUFunc_FromFuncAndData(ufunc_chndtridf_loops, ufunc_chndtridf_data, ufunc_chndtridf_types, 2, 3, 1, 0, "chndtridf", ufunc_chndtridf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chndtrinc_loops[2]
cdef void *ufunc_chndtrinc_ptr[4]
cdef void *ufunc_chndtrinc_data[2]
cdef char ufunc_chndtrinc_types[8]
cdef char *ufunc_chndtrinc_doc = (
    "chndtrinc(x, df, p, out=None)\n"
    "\n"
    "Inverse to `chndtr` vs `nc`\n"
    "\n"
    "Calculated using a search to find a value for `df` that produces the\n"
    "desired value of `p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Upper bound of the integral; must satisfy ``x >= 0``\n"
    "df : array_like\n"
    "    Degrees of freedom; must satisfy ``df > 0``\n"
    "p : array_like\n"
    "    Probability; must satisfy ``0 <= p < 1``\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "nc : scalar or ndarray\n"
    "    Non-centrality\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chndtr, chndtrix, chndtrinc")
ufunc_chndtrinc_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_chndtrinc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_chndtrinc_types[0] = <char>NPY_FLOAT
ufunc_chndtrinc_types[1] = <char>NPY_FLOAT
ufunc_chndtrinc_types[2] = <char>NPY_FLOAT
ufunc_chndtrinc_types[3] = <char>NPY_FLOAT
ufunc_chndtrinc_types[4] = <char>NPY_DOUBLE
ufunc_chndtrinc_types[5] = <char>NPY_DOUBLE
ufunc_chndtrinc_types[6] = <char>NPY_DOUBLE
ufunc_chndtrinc_types[7] = <char>NPY_DOUBLE
ufunc_chndtrinc_ptr[2*0] = <void*>_func_chndtrinc
ufunc_chndtrinc_ptr[2*0+1] = <void*>(<char*>"chndtrinc")
ufunc_chndtrinc_ptr[2*1] = <void*>_func_chndtrinc
ufunc_chndtrinc_ptr[2*1+1] = <void*>(<char*>"chndtrinc")
ufunc_chndtrinc_data[0] = &ufunc_chndtrinc_ptr[2*0]
ufunc_chndtrinc_data[1] = &ufunc_chndtrinc_ptr[2*1]
chndtrinc = np.PyUFunc_FromFuncAndData(ufunc_chndtrinc_loops, ufunc_chndtrinc_data, ufunc_chndtrinc_types, 2, 3, 1, 0, "chndtrinc", ufunc_chndtrinc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chndtrix_loops[2]
cdef void *ufunc_chndtrix_ptr[4]
cdef void *ufunc_chndtrix_data[2]
cdef char ufunc_chndtrix_types[8]
cdef char *ufunc_chndtrix_doc = (
    "chndtrix(p, df, nc, out=None)\n"
    "\n"
    "Inverse to `chndtr` vs `x`\n"
    "\n"
    "Calculated using a search to find a value for `x` that produces the\n"
    "desired value of `p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Probability; must satisfy ``0 <= p < 1``\n"
    "df : array_like\n"
    "    Degrees of freedom; must satisfy ``df > 0``\n"
    "nc : array_like\n"
    "    Non-centrality parameter; must satisfy ``nc >= 0``\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    Value so that the probability a non-central Chi square random variable\n"
    "    with `df` degrees of freedom and non-centrality, `nc`, is greater than\n"
    "    `x` equals `p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chndtr, chndtridf, chndtrinc")
ufunc_chndtrix_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_chndtrix_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_chndtrix_types[0] = <char>NPY_FLOAT
ufunc_chndtrix_types[1] = <char>NPY_FLOAT
ufunc_chndtrix_types[2] = <char>NPY_FLOAT
ufunc_chndtrix_types[3] = <char>NPY_FLOAT
ufunc_chndtrix_types[4] = <char>NPY_DOUBLE
ufunc_chndtrix_types[5] = <char>NPY_DOUBLE
ufunc_chndtrix_types[6] = <char>NPY_DOUBLE
ufunc_chndtrix_types[7] = <char>NPY_DOUBLE
ufunc_chndtrix_ptr[2*0] = <void*>_func_chndtrix
ufunc_chndtrix_ptr[2*0+1] = <void*>(<char*>"chndtrix")
ufunc_chndtrix_ptr[2*1] = <void*>_func_chndtrix
ufunc_chndtrix_ptr[2*1+1] = <void*>(<char*>"chndtrix")
ufunc_chndtrix_data[0] = &ufunc_chndtrix_ptr[2*0]
ufunc_chndtrix_data[1] = &ufunc_chndtrix_ptr[2*1]
chndtrix = np.PyUFunc_FromFuncAndData(ufunc_chndtrix_loops, ufunc_chndtrix_data, ufunc_chndtrix_types, 2, 3, 1, 0, "chndtrix", ufunc_chndtrix_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_cosdg_loops[2]
cdef void *ufunc_cosdg_ptr[4]
cdef void *ufunc_cosdg_data[2]
cdef char ufunc_cosdg_types[4]
cdef char *ufunc_cosdg_doc = (
    "cosdg(x, out=None)\n"
    "\n"
    "Cosine of the angle `x` given in degrees.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Angle, given in degrees.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Cosine of the input.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "sindg, tandg, cotdg\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is more accurate than using cosine directly.\n"
    "\n"
    ">>> x = 90 + 180 * np.arange(3)\n"
    ">>> sc.cosdg(x)\n"
    "array([-0.,  0., -0.])\n"
    ">>> np.cos(x * np.pi / 180)\n"
    "array([ 6.1232340e-17, -1.8369702e-16,  3.0616170e-16])")
ufunc_cosdg_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_cosdg_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_cosdg_types[0] = <char>NPY_FLOAT
ufunc_cosdg_types[1] = <char>NPY_FLOAT
ufunc_cosdg_types[2] = <char>NPY_DOUBLE
ufunc_cosdg_types[3] = <char>NPY_DOUBLE
ufunc_cosdg_ptr[2*0] = <void*>_func_cosdg
ufunc_cosdg_ptr[2*0+1] = <void*>(<char*>"cosdg")
ufunc_cosdg_ptr[2*1] = <void*>_func_cosdg
ufunc_cosdg_ptr[2*1+1] = <void*>(<char*>"cosdg")
ufunc_cosdg_data[0] = &ufunc_cosdg_ptr[2*0]
ufunc_cosdg_data[1] = &ufunc_cosdg_ptr[2*1]
cosdg = np.PyUFunc_FromFuncAndData(ufunc_cosdg_loops, ufunc_cosdg_data, ufunc_cosdg_types, 2, 1, 1, 0, "cosdg", ufunc_cosdg_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_cosm1_loops[2]
cdef void *ufunc_cosm1_ptr[4]
cdef void *ufunc_cosm1_data[2]
cdef char ufunc_cosm1_types[4]
cdef char *ufunc_cosm1_doc = (
    "cosm1(x, out=None)\n"
    "\n"
    "cos(x) - 1 for use when `x` is near zero.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real valued argument.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of ``cos(x) - 1``.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "expm1, log1p\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is more accurate than computing ``cos(x) - 1`` directly for\n"
    "``x`` around 0.\n"
    "\n"
    ">>> x = 1e-30\n"
    ">>> np.cos(x) - 1\n"
    "0.0\n"
    ">>> sc.cosm1(x)\n"
    "-5.0000000000000005e-61")
ufunc_cosm1_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_cosm1_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_cosm1_types[0] = <char>NPY_FLOAT
ufunc_cosm1_types[1] = <char>NPY_FLOAT
ufunc_cosm1_types[2] = <char>NPY_DOUBLE
ufunc_cosm1_types[3] = <char>NPY_DOUBLE
ufunc_cosm1_ptr[2*0] = <void*>_func_cosm1
ufunc_cosm1_ptr[2*0+1] = <void*>(<char*>"cosm1")
ufunc_cosm1_ptr[2*1] = <void*>_func_cosm1
ufunc_cosm1_ptr[2*1+1] = <void*>(<char*>"cosm1")
ufunc_cosm1_data[0] = &ufunc_cosm1_ptr[2*0]
ufunc_cosm1_data[1] = &ufunc_cosm1_ptr[2*1]
cosm1 = np.PyUFunc_FromFuncAndData(ufunc_cosm1_loops, ufunc_cosm1_data, ufunc_cosm1_types, 2, 1, 1, 0, "cosm1", ufunc_cosm1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_cotdg_loops[2]
cdef void *ufunc_cotdg_ptr[4]
cdef void *ufunc_cotdg_data[2]
cdef char ufunc_cotdg_types[4]
cdef char *ufunc_cotdg_doc = (
    "cotdg(x, out=None)\n"
    "\n"
    "Cotangent of the angle `x` given in degrees.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Angle, given in degrees.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Cotangent at the input.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "sindg, cosdg, tandg\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is more accurate than using cotangent directly.\n"
    "\n"
    ">>> x = 90 + 180 * np.arange(3)\n"
    ">>> sc.cotdg(x)\n"
    "array([0., 0., 0.])\n"
    ">>> 1 / np.tan(x * np.pi / 180)\n"
    "array([6.1232340e-17, 1.8369702e-16, 3.0616170e-16])")
ufunc_cotdg_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_cotdg_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_cotdg_types[0] = <char>NPY_FLOAT
ufunc_cotdg_types[1] = <char>NPY_FLOAT
ufunc_cotdg_types[2] = <char>NPY_DOUBLE
ufunc_cotdg_types[3] = <char>NPY_DOUBLE
ufunc_cotdg_ptr[2*0] = <void*>_func_cotdg
ufunc_cotdg_ptr[2*0+1] = <void*>(<char*>"cotdg")
ufunc_cotdg_ptr[2*1] = <void*>_func_cotdg
ufunc_cotdg_ptr[2*1+1] = <void*>(<char*>"cotdg")
ufunc_cotdg_data[0] = &ufunc_cotdg_ptr[2*0]
ufunc_cotdg_data[1] = &ufunc_cotdg_ptr[2*1]
cotdg = np.PyUFunc_FromFuncAndData(ufunc_cotdg_loops, ufunc_cotdg_data, ufunc_cotdg_types, 2, 1, 1, 0, "cotdg", ufunc_cotdg_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_dawsn_loops[4]
cdef void *ufunc_dawsn_ptr[8]
cdef void *ufunc_dawsn_data[4]
cdef char ufunc_dawsn_types[8]
cdef char *ufunc_dawsn_doc = (
    "dawsn(x, out=None)\n"
    "\n"
    "Dawson's integral.\n"
    "\n"
    "Computes::\n"
    "\n"
    "    exp(-x**2) * integral(exp(t**2), t=0..x).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Function parameter.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Value of the integral.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "wofz, erf, erfc, erfcx, erfi\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Steven G. Johnson, Faddeeva W function implementation.\n"
    "   http://ab-initio.mit.edu/Faddeeva\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy import special\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-15, 15, num=1000)\n"
    ">>> plt.plot(x, special.dawsn(x))\n"
    ">>> plt.xlabel('$x$')\n"
    ">>> plt.ylabel('$dawsn(x)$')\n"
    ">>> plt.show()")
ufunc_dawsn_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_dawsn_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_dawsn_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_dawsn_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_dawsn_types[0] = <char>NPY_FLOAT
ufunc_dawsn_types[1] = <char>NPY_FLOAT
ufunc_dawsn_types[2] = <char>NPY_DOUBLE
ufunc_dawsn_types[3] = <char>NPY_DOUBLE
ufunc_dawsn_types[4] = <char>NPY_CFLOAT
ufunc_dawsn_types[5] = <char>NPY_CFLOAT
ufunc_dawsn_types[6] = <char>NPY_CDOUBLE
ufunc_dawsn_types[7] = <char>NPY_CDOUBLE
ufunc_dawsn_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_dawsn
ufunc_dawsn_ptr[2*0+1] = <void*>(<char*>"dawsn")
ufunc_dawsn_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_dawsn
ufunc_dawsn_ptr[2*1+1] = <void*>(<char*>"dawsn")
ufunc_dawsn_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_dawsn_complex
ufunc_dawsn_ptr[2*2+1] = <void*>(<char*>"dawsn")
ufunc_dawsn_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_dawsn_complex
ufunc_dawsn_ptr[2*3+1] = <void*>(<char*>"dawsn")
ufunc_dawsn_data[0] = &ufunc_dawsn_ptr[2*0]
ufunc_dawsn_data[1] = &ufunc_dawsn_ptr[2*1]
ufunc_dawsn_data[2] = &ufunc_dawsn_ptr[2*2]
ufunc_dawsn_data[3] = &ufunc_dawsn_ptr[2*3]
dawsn = np.PyUFunc_FromFuncAndData(ufunc_dawsn_loops, ufunc_dawsn_data, ufunc_dawsn_types, 4, 1, 1, 0, "dawsn", ufunc_dawsn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ellipe_loops[2]
cdef void *ufunc_ellipe_ptr[4]
cdef void *ufunc_ellipe_data[2]
cdef char ufunc_ellipe_types[4]
cdef char *ufunc_ellipe_doc = (
    "ellipe(m, out=None)\n"
    "\n"
    "Complete elliptic integral of the second kind\n"
    "\n"
    "This function is defined as\n"
    "\n"
    ".. math:: E(m) = \\int_0^{\\pi/2} [1 - m \\sin(t)^2]^{1/2} dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Defines the parameter of the elliptic integral.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "E : scalar or ndarray\n"
    "    Value of the elliptic integral.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ellipkm1 : Complete elliptic integral of the first kind, near `m` = 1\n"
    "ellipk : Complete elliptic integral of the first kind\n"
    "ellipkinc : Incomplete elliptic integral of the first kind\n"
    "ellipeinc : Incomplete elliptic integral of the second kind\n"
    "elliprd : Symmetric elliptic integral of the second kind.\n"
    "elliprg : Completely-symmetric elliptic integral of the second kind.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the Cephes [1]_ routine `ellpe`.\n"
    "\n"
    "For `m > 0` the computation uses the approximation,\n"
    "\n"
    ".. math:: E(m) \\approx P(1-m) - (1-m) \\log(1-m) Q(1-m),\n"
    "\n"
    "where :math:`P` and :math:`Q` are tenth-order polynomials.  For\n"
    "`m < 0`, the relation\n"
    "\n"
    ".. math:: E(m) = E(m/(m - 1)) \\sqrt(1-m)\n"
    "\n"
    "is used.\n"
    "\n"
    "The parameterization in terms of :math:`m` follows that of section\n"
    "17.2 in [2]_. Other parameterizations in terms of the\n"
    "complementary parameter :math:`1 - m`, modular angle\n"
    ":math:`\\sin^2(\\alpha) = m`, or modulus :math:`k^2 = m` are also\n"
    "used, so be careful that you choose the correct parameter.\n"
    "\n"
    "The Legendre E integral is related to Carlson's symmetric R_D or R_G\n"
    "functions in multiple ways [3]_. For example,\n"
    "\n"
    ".. math:: E(m) = 2 R_G(0, 1-k^2, 1) .\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    ".. [2] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    ".. [3] NIST Digital Library of Mathematical\n"
    "       Functions. http://dlmf.nist.gov/, Release 1.0.28 of\n"
    "       2020-09-15. See Sec. 19.25(i) https://dlmf.nist.gov/19.25#i\n"
    "\n"
    "Examples\n"
    "--------\n"
    "This function is used in finding the circumference of an\n"
    "ellipse with semi-major axis `a` and semi-minor axis `b`.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy import special\n"
    "\n"
    ">>> a = 3.5\n"
    ">>> b = 2.1\n"
    ">>> e_sq = 1.0 - b**2/a**2  # eccentricity squared\n"
    "\n"
    "Then the circumference is found using the following:\n"
    "\n"
    ">>> C = 4*a*special.ellipe(e_sq)  # circumference formula\n"
    ">>> C\n"
    "17.868899204378693\n"
    "\n"
    "When `a` and `b` are the same (meaning eccentricity is 0),\n"
    "this reduces to the circumference of a circle.\n"
    "\n"
    ">>> 4*a*special.ellipe(0.0)  # formula for ellipse with a = b\n"
    "21.991148575128552\n"
    ">>> 2*np.pi*a  # formula for circle of radius a\n"
    "21.991148575128552")
ufunc_ellipe_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_ellipe_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_ellipe_types[0] = <char>NPY_FLOAT
ufunc_ellipe_types[1] = <char>NPY_FLOAT
ufunc_ellipe_types[2] = <char>NPY_DOUBLE
ufunc_ellipe_types[3] = <char>NPY_DOUBLE
ufunc_ellipe_ptr[2*0] = <void*>_func_ellpe
ufunc_ellipe_ptr[2*0+1] = <void*>(<char*>"ellipe")
ufunc_ellipe_ptr[2*1] = <void*>_func_ellpe
ufunc_ellipe_ptr[2*1+1] = <void*>(<char*>"ellipe")
ufunc_ellipe_data[0] = &ufunc_ellipe_ptr[2*0]
ufunc_ellipe_data[1] = &ufunc_ellipe_ptr[2*1]
ellipe = np.PyUFunc_FromFuncAndData(ufunc_ellipe_loops, ufunc_ellipe_data, ufunc_ellipe_types, 2, 1, 1, 0, "ellipe", ufunc_ellipe_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ellipeinc_loops[2]
cdef void *ufunc_ellipeinc_ptr[4]
cdef void *ufunc_ellipeinc_data[2]
cdef char ufunc_ellipeinc_types[6]
cdef char *ufunc_ellipeinc_doc = (
    "ellipeinc(phi, m, out=None)\n"
    "\n"
    "Incomplete elliptic integral of the second kind\n"
    "\n"
    "This function is defined as\n"
    "\n"
    ".. math:: E(\\phi, m) = \\int_0^{\\phi} [1 - m \\sin(t)^2]^{1/2} dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "phi : array_like\n"
    "    amplitude of the elliptic integral.\n"
    "m : array_like\n"
    "    parameter of the elliptic integral.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "E : scalar or ndarray\n"
    "    Value of the elliptic integral.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ellipkm1 : Complete elliptic integral of the first kind, near `m` = 1\n"
    "ellipk : Complete elliptic integral of the first kind\n"
    "ellipkinc : Incomplete elliptic integral of the first kind\n"
    "ellipe : Complete elliptic integral of the second kind\n"
    "elliprd : Symmetric elliptic integral of the second kind.\n"
    "elliprf : Completely-symmetric elliptic integral of the first kind.\n"
    "elliprg : Completely-symmetric elliptic integral of the second kind.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the Cephes [1]_ routine `ellie`.\n"
    "\n"
    "Computation uses arithmetic-geometric means algorithm.\n"
    "\n"
    "The parameterization in terms of :math:`m` follows that of section\n"
    "17.2 in [2]_. Other parameterizations in terms of the\n"
    "complementary parameter :math:`1 - m`, modular angle\n"
    ":math:`\\sin^2(\\alpha) = m`, or modulus :math:`k^2 = m` are also\n"
    "used, so be careful that you choose the correct parameter.\n"
    "\n"
    "The Legendre E incomplete integral can be related to combinations\n"
    "of Carlson's symmetric integrals R_D, R_F, and R_G in multiple\n"
    "ways [3]_. For example, with :math:`c = \\csc^2\\phi`,\n"
    "\n"
    ".. math::\n"
    "  E(\\phi, m) = R_F(c-1, c-k^2, c)\n"
    "    - \\frac{1}{3} k^2 R_D(c-1, c-k^2, c) .\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    ".. [2] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    ".. [3] NIST Digital Library of Mathematical\n"
    "       Functions. http://dlmf.nist.gov/, Release 1.0.28 of\n"
    "       2020-09-15. See Sec. 19.25(i) https://dlmf.nist.gov/19.25#i")
ufunc_ellipeinc_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_ellipeinc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_ellipeinc_types[0] = <char>NPY_FLOAT
ufunc_ellipeinc_types[1] = <char>NPY_FLOAT
ufunc_ellipeinc_types[2] = <char>NPY_FLOAT
ufunc_ellipeinc_types[3] = <char>NPY_DOUBLE
ufunc_ellipeinc_types[4] = <char>NPY_DOUBLE
ufunc_ellipeinc_types[5] = <char>NPY_DOUBLE
ufunc_ellipeinc_ptr[2*0] = <void*>_func_ellie
ufunc_ellipeinc_ptr[2*0+1] = <void*>(<char*>"ellipeinc")
ufunc_ellipeinc_ptr[2*1] = <void*>_func_ellie
ufunc_ellipeinc_ptr[2*1+1] = <void*>(<char*>"ellipeinc")
ufunc_ellipeinc_data[0] = &ufunc_ellipeinc_ptr[2*0]
ufunc_ellipeinc_data[1] = &ufunc_ellipeinc_ptr[2*1]
ellipeinc = np.PyUFunc_FromFuncAndData(ufunc_ellipeinc_loops, ufunc_ellipeinc_data, ufunc_ellipeinc_types, 2, 2, 1, 0, "ellipeinc", ufunc_ellipeinc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ellipj_loops[2]
cdef void *ufunc_ellipj_ptr[4]
cdef void *ufunc_ellipj_data[2]
cdef char ufunc_ellipj_types[12]
cdef char *ufunc_ellipj_doc = (
    "ellipj(u, m, out=None)\n"
    "\n"
    "Jacobian elliptic functions\n"
    "\n"
    "Calculates the Jacobian elliptic functions of parameter `m` between\n"
    "0 and 1, and real argument `u`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Parameter.\n"
    "u : array_like\n"
    "    Argument.\n"
    "out : tuple of ndarray, optional\n"
    "    Optional output arrays for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "sn, cn, dn, ph : 4-tuple of scalar or ndarray\n"
    "    The returned functions::\n"
    "\n"
    "        sn(u|m), cn(u|m), dn(u|m)\n"
    "\n"
    "    The value `ph` is such that if `u = ellipkinc(ph, m)`,\n"
    "    then `sn(u|m) = sin(ph)` and `cn(u|m) = cos(ph)`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ellipk : Complete elliptic integral of the first kind\n"
    "ellipkinc : Incomplete elliptic integral of the first kind\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the Cephes [1]_ routine `ellpj`.\n"
    "\n"
    "These functions are periodic, with quarter-period on the real axis\n"
    "equal to the complete elliptic integral `ellipk(m)`.\n"
    "\n"
    "Relation to incomplete elliptic integral: If `u = ellipkinc(phi,m)`, then\n"
    "`sn(u|m) = sin(phi)`, and `cn(u|m) = cos(phi)`. The `phi` is called\n"
    "the amplitude of `u`.\n"
    "\n"
    "Computation is by means of the arithmetic-geometric mean algorithm,\n"
    "except when `m` is within 1e-9 of 0 or 1. In the latter case with `m`\n"
    "close to 1, the approximation applies only for `phi < pi/2`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/")
ufunc_ellipj_loops[0] = <np.PyUFuncGenericFunction>loop_i_dd_dddd_As_ff_ffff
ufunc_ellipj_loops[1] = <np.PyUFuncGenericFunction>loop_i_dd